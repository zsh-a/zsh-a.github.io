<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>algorithm template</title>
    <link href="/2020/07/05/code%20template/"/>
    <url>/2020/07/05/code%20template/</url>
    
    <content type="html"><![CDATA[<h1 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h1><h2 id="0x00排序"><a href="#0x00排序" class="headerlink" title="0x00排序"></a>0x00排序</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>给定你一个长度为n的整数数列。</p><p>请你使用快速排序对这个数列按照从小到大进行排序。</p><p>并将排好序的数列按顺序输出。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入共两行，第一行包含整数 n。</p><p>第二行包含 n 个整数（所有整数均在$1-10^{9}$范围内），表示整个数列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出共一行，包含 n 个整数，表示排好序的数列。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤n≤100000m$</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><p>5<br>3 1 2 4 5</p><h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h4><p>1 2 3 4 5</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> d[M];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>&#123;    <span class="hljs-keyword">if</span>(l &gt;=r )        <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> i = l <span class="hljs-number">-1</span>,j = r + <span class="hljs-number">1</span>,pivo = d[l + r &gt;&gt; <span class="hljs-number">1</span>];    <span class="hljs-keyword">while</span>(i &lt; j)&#123;        <span class="hljs-keyword">while</span>(d[++i] &lt; pivo);        <span class="hljs-keyword">while</span>(d[--j] &gt; pivo);        <span class="hljs-keyword">if</span>(i &lt; j) swap(d[i],d[j]);    &#125;    qs(l,j);    qs(j + <span class="hljs-number">1</span>,r);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i ++ )&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;d[i]);    &#125;    qs(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,d[i]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> d[M],tmp[M];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>&#123;    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;    merge_sort(l,mid), merge_sort(mid + <span class="hljs-number">1</span>,r);    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>,i = l,j = mid + <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;        <span class="hljs-keyword">if</span>(d[i] &lt;= d[j]) tmp[k++] = d[i++];        <span class="hljs-keyword">else</span> tmp[k++] = d[j++];    &#125;    <span class="hljs-keyword">while</span>(i &lt;= mid) tmp[k++] = d[i++];    <span class="hljs-keyword">while</span>(j &lt;= r) tmp[k++] = d[j++];    <span class="hljs-keyword">for</span>(i = l,j = <span class="hljs-number">0</span>;j &lt; k;j++,i++) d[i] = tmp[j];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i ++ )&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;d[i]);    &#125;    merge_sort(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,d[i]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="0x01高精度"><a href="#0x01高精度" class="headerlink" title="0x01高精度"></a>0x01高精度</h2><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;    <span class="hljs-keyword">int</span> c= <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; A.<span class="hljs-built_in">size</span>() || i &lt;B.<span class="hljs-built_in">size</span>();i++)&#123;        <span class="hljs-keyword">if</span>(i &lt; A.<span class="hljs-built_in">size</span>()) c += A[i];        <span class="hljs-keyword">if</span>(i &lt; B.<span class="hljs-built_in">size</span>()) c += B[i];        res.push_back(c % <span class="hljs-number">10</span>);        c/= <span class="hljs-number">10</span>;    &#125;    <span class="hljs-keyword">if</span>(c) res.push_back(c);    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h3 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h3><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; A,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; B)</span></span>&#123;    <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; A.<span class="hljs-built_in">size</span>();i++)&#123;        c = A[i] - c;        <span class="hljs-keyword">if</span>(i &lt; B.<span class="hljs-built_in">size</span>()) c = c - B[i];        res.push_back((c + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);        <span class="hljs-keyword">if</span>(c &lt; <span class="hljs-number">0</span>) c = <span class="hljs-number">1</span>; <span class="hljs-comment">// 有借位</span>        <span class="hljs-keyword">else</span> c = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">while</span>(res.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; res.back()==<span class="hljs-number">0</span>) res.pop_back();<span class="hljs-comment">// 去掉前导 0</span>    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; A,<span class="hljs-keyword">int</span> b)</span></span>&#123;    <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; A.<span class="hljs-built_in">size</span>();i++)&#123;        c += A[i]*b;        res.push_back(c % <span class="hljs-number">10</span>);        c /= <span class="hljs-number">10</span>;    &#125;      <span class="hljs-keyword">if</span>(c) res.push_back(c);    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; A,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span>&amp; r)</span></span>&#123;    r = <span class="hljs-number">0</span>;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = A.<span class="hljs-built_in">size</span>() <span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;        r = r * <span class="hljs-number">10</span> + A[i];        res.push_back(r / b);        r = r % b;    &#125;    reverse(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());    <span class="hljs-keyword">while</span>(res.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; res.back() == <span class="hljs-number">0</span>) res.pop_back();    <span class="hljs-keyword">return</span> res;&#125;</code></pre><h2 id="0x02-前缀和差分"><a href="#0x02-前缀和差分" class="headerlink" title="0x02 前缀和差分"></a>0x02 前缀和差分</h2><p>将$[l,r] + c$ 操作变为$O(1)$</p><h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><p>输入一个长度为n的整数序列。</p><p>接下来输入m个操作，每个操作包含三个整数l, r, c，表示将序列中[l, r]之间的每个数加上c。</p><p>请你输出进行完所有操作后的序列。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数n和m。</p><p>第二行包含n个整数，表示整数序列。</p><p>接下来m行，每行包含三个整数l，r，c，表示一个操作。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含n个整数，表示最终序列。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤n,m≤100000,$<br>$1≤l≤r≤n,$<br>$−1000≤c≤1000,$<br>$−1000≤整数序列中元素的值≤1000$ </p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><p>6 3<br>1 2 2 1 2 1<br>1 3 1<br>3 5 1<br>1 6 1</p><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><p>3 4 5 3 4 2</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> a[M],b[M];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n,m;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i  =<span class="hljs-number">1</span>;i &lt;=n;i++) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);        b[i] = a[i] - a[i<span class="hljs-number">-1</span>]; <span class="hljs-comment">// 计算差分</span>    &#125;    <span class="hljs-keyword">while</span>(m--)&#123;        <span class="hljs-keyword">int</span> l,r,c;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;c);        b[l] += c;        b[r+<span class="hljs-number">1</span>] -= c;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;=n;i++) b[i] +=b[i<span class="hljs-number">-1</span>]; <span class="hljs-comment">// 求前缀和</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;=n;i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,b[i]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="矩阵差分"><a href="#矩阵差分" class="headerlink" title="矩阵差分"></a>矩阵差分</h3><p>输入一个n行m列的整数矩阵，再输入q个操作，每个操作包含五个整数x1, y1, x2, y2, c，其中(x1, y1)和(x2, y2)表示一个子矩阵的左上角坐标和右下角坐标。</p><p>每个操作都要将选中的子矩阵中的每个元素的值加上c。</p><p>请你将进行完所有操作后的矩阵输出。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数n,m,q。</p><p>接下来n行，每行包含m个整数，表示整数矩阵。</p><p>接下来q行，每行包含5个整数x1, y1, x2, y2, c，表示一个操作。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤n,m≤1000,$<br>$1≤q≤100000,$<br>$1≤x1≤x2≤n,$<br>$1≤y1≤y2≤m,$<br>$−1000≤c≤1000,$<br>$−1000≤矩阵内元素的值≤1000$  </p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><p>3 4 3<br>1 2 2 1<br>3 2 2 1<br>1 1 1 1<br>1 1 2 2 1<br>1 3 2 3 2<br>3 1 3 4 1  </p><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><p>2 3 4 1<br>4 3 4 1<br>2 2 2 2  </p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1010</span>;<span class="hljs-keyword">int</span> a[M][M],b[M][M];<span class="hljs-comment">// 插入</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1,<span class="hljs-keyword">int</span> y1,<span class="hljs-keyword">int</span> x2,<span class="hljs-keyword">int</span> y2,<span class="hljs-keyword">int</span> c)</span></span>&#123;    b[x1][y1] += c;    b[x2 + <span class="hljs-number">1</span>][y1] -= c;    b[x1][y2+<span class="hljs-number">1</span>] -= c;    b[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>] += c;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n,m,q;    <span class="hljs-built_in">cin</span> &gt;&gt; n&gt;&gt;m&gt;&gt;q;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i &lt;=n;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt;=m;j++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i][j]), insert(i,j,i,j,a[i][j]);    <span class="hljs-keyword">while</span>(q--)&#123;        <span class="hljs-keyword">int</span> x1,x2,y1,y2,c;        <span class="hljs-built_in">cin</span> &gt;&gt; x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;        insert(x1,y1,x2,y2,c);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;=n;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt;=m;j++)            b[i][j] += b[i<span class="hljs-number">-1</span>][j] + b[i][j<span class="hljs-number">-1</span>] - b[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<span class="hljs-comment">// 求前缀和</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;=n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt;=m;j++)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,b[i][j]);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="区间离散"><a href="#区间离散" class="headerlink" title="区间离散"></a>区间离散</h3><p>假定有一个无限长的数轴，数轴上每个坐标上的数都是0。</p><p>现在，我们首先进行 n 次操作，每次操作将某一位置x上的数加c。</p><p>近下来，进行 m 次询问，每个询问包含两个整数l和r，你需要求出在区间[l, r]之间的所有数的和。</p><p>输入格式<br>第一行包含两个整数n和m。</p><p>接下来 n 行，每行包含两个整数x和c。</p><p>再接下里 m 行，每行包含两个整数l和r。</p><h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>共m行，每行输出一个询问中所求的区间内数字和。</p><h4 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h4><p>$−109≤x≤109,$<br>$1≤n,m≤105,$<br>$−109≤l≤r≤109,$<br>$−10000≤c≤10000$  </p><h4 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h4><p>3 3<br>1 2<br>3 6<br>7 5<br>1 3<br>4 6<br>7 8</p><h4 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例"></a>输出样例</h4><p>8<br>0<br>5</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> PII = pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">3e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> a[M],b[M];<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; alls; <span class="hljs-comment">// 所有使用到的点</span><span class="hljs-built_in">vector</span>&lt;PII&gt; add,query;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>,r = alls.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;    <span class="hljs-keyword">while</span>(l &lt; r)&#123;        <span class="hljs-keyword">int</span> mid = l + r &gt;&gt;<span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(alls[mid]&gt;=x) r = mid;        <span class="hljs-keyword">else</span> l = mid +<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> l + <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">int</span> n,m;    <span class="hljs-built_in">cin</span> &gt;&gt;n&gt;&gt;m;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)&#123;        <span class="hljs-keyword">int</span> x,y;        <span class="hljs-built_in">cin</span> &gt;&gt;x&gt;&gt;y;        add.push_back(&#123;x,y&#125;);        alls.push_back(x);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)&#123;        <span class="hljs-keyword">int</span> x,y;        <span class="hljs-built_in">cin</span> &gt;&gt; x&gt;&gt;y;        query.push_back(&#123;x,y&#125;);        alls.push_back(x);        alls.push_back(y);    &#125;    sort(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>());    alls.erase(unique(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>()), alls.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 去重</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : add)&#123;        <span class="hljs-keyword">int</span> x = <span class="hljs-built_in">find</span>(it.first);        a[x] += it.second;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;=alls.<span class="hljs-built_in">size</span>();i++)        b[i] = b[i<span class="hljs-number">-1</span>] + a[i];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : query)&#123;        <span class="hljs-keyword">int</span> x = <span class="hljs-built_in">find</span>(it.first),y = <span class="hljs-built_in">find</span>(it.second);        <span class="hljs-built_in">cout</span> &lt;&lt; b[y] - b[x<span class="hljs-number">-1</span>] &lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h2><p>给定一个模式串S，以及一个模板串P，所有字符串中只包含大小写英文字母以及阿拉伯数字。</p><p>模板串P在模式串S中多次作为子串出现。</p><p>求出模板串P在模式串S中所有出现的位置的起始下标。</p><h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入整数N，表示字符串P的长度。</p><p>第二行输入字符串P。</p><p>第三行输入整数M，表示字符串S的长度。</p><p>第四行输入字符串S。</p><h4 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，输出所有出现位置的起始下标（下标从0开始计数），整数之间用空格隔开。</p><h4 id="数据范围-4"><a href="#数据范围-4" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤N≤10^4$<br>$1≤M≤10^5$  </p><h4 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例"></a>输入样例</h4><p>3<br>aba<br>5<br>ababa</p><h4 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例"></a>输出样例</h4><p>0 2</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">char</span> s[M],p[M];<span class="hljs-keyword">int</span> ne[M];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n,m;    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; p + <span class="hljs-number">1</span>&gt;&gt;m &gt;&gt; s + <span class="hljs-number">1</span>;    <span class="hljs-comment">/*</span><span class="hljs-comment">        next[] 从1开始, [1,i] 最大前缀与后缀相同长度</span><span class="hljs-comment">        eg:</span><span class="hljs-comment">            p : "ababa"</span><span class="hljs-comment">                 12345</span><span class="hljs-comment">            next 0 1 2 3 4 5</span><span class="hljs-comment">                 0 0 0 1 2 3</span><span class="hljs-comment">    */</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>,j = <span class="hljs-number">0</span>;i &lt;=n;i++)&#123;        <span class="hljs-comment">// 用 p[j + 1] 和 j[i]  匹配 ， 若失败 则 j = next[j]</span>        <span class="hljs-keyword">while</span>(j &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];        <span class="hljs-keyword">if</span>(p[i] == p[j + <span class="hljs-number">1</span>]) j++;        ne[i] = j;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>,j = <span class="hljs-number">0</span>;i &lt;=m;i++)&#123;        <span class="hljs-keyword">while</span>(j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];        <span class="hljs-keyword">if</span>(s[i] == p[j + <span class="hljs-number">1</span>]) j++;        <span class="hljs-keyword">if</span>(j == n )&#123;            <span class="hljs-comment">// succ</span>            <span class="hljs-built_in">cout</span> &lt;&lt; i - n &lt;&lt;<span class="hljs-string">" "</span>;            j = ne[j];        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><blockquote><p>高效存储和查找字符串<br>维护一个字符串集合，支持两种操作：</p></blockquote><p>“I x”向集合中插入一个字符串x；<br>“Q x”询问一个字符串在集合中出现了多少次。<br>共有N个操作，输入的字符串总长度不超过 105，字符串仅包含小写英文字母。</p><h4 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数N，表示操作数。</p><p>接下来N行，每行包含一个操作指令，指令为”I x”或”Q x”中的一种。</p><h4 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个询问指令”Q x”，都要输出一个整数作为结果，表示x在集合中出现的次数。</p><p>每个结果占一行。</p><h4 id="数据范围-5"><a href="#数据范围-5" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤N≤2∗104$</p><h4 id="输入样例-3"><a href="#输入样例-3" class="headerlink" title="输入样例"></a>输入样例</h4><p>5<br>I abc<br>Q abc<br>Q ab<br>I ab<br>Q ab  </p><h4 id="输出样例-3"><a href="#输出样例-3" class="headerlink" title="输出样例"></a>输出样例</h4><p>1<br>0<br>1</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> son[M][<span class="hljs-number">26</span>],cnt[M],idx; <span class="hljs-comment">// idx : 0 表示根节点</span><span class="hljs-keyword">char</span> str[M];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* str)</span></span>&#123;    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; str[i];i++)&#123;        <span class="hljs-keyword">int</span> u = str[i] - <span class="hljs-string">'a'</span>;        <span class="hljs-keyword">if</span>(!son[p][u]) son[p][u] = ++idx;        p = son[p][u];    &#125;    cnt[p] ++;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* str)</span></span>&#123;    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;str[i];i++)&#123;        <span class="hljs-keyword">int</span> u = str[i] - <span class="hljs-string">'a'</span>;        <span class="hljs-keyword">if</span>(!son[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        p = son[p][u];    &#125;    <span class="hljs-keyword">return</span> cnt[p];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">cin</span> &gt;&gt; n;    <span class="hljs-keyword">while</span>(n--)&#123;        <span class="hljs-keyword">char</span> op;        <span class="hljs-built_in">cin</span> &gt;&gt; op;        <span class="hljs-built_in">cin</span>&gt;&gt; str;        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">'I'</span>)&#123;            insert(str);        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">cout</span> &lt;&lt; query(str) &lt;&lt;<span class="hljs-string">"\n"</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>给定一个包含n个点（编号为1~n）的无向图，初始时图中没有边。</p><p>现在要进行m个操作，操作共有三种：</p><p>“C a b”，在点a和点b之间连一条边，a和b可能相等；<br>“Q1 a b”，询问点a和点b是否在同一个连通块中，a和b可能相等；<br>“Q2 a”，询问点a所在连通块中点的数量；</p><h4 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入整数n和m。</p><p>接下来m行，每行包含一个操作指令，指令为“C a b”，“Q1 a b”或“Q2 a”中的一种。</p><h4 id="输出格式-6"><a href="#输出格式-6" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个询问指令”Q1 a b”，如果a和b在同一个连通块中，则输出“Yes”，否则输出“No”。</p><p>对于每个询问指令“Q2 a”，输出一个整数表示点a所在连通块中点的数量</p><p>每个结果占一行。</p><h4 id="数据范围-6"><a href="#数据范围-6" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤n,m≤10^5$</p><h4 id="输入样例-4"><a href="#输入样例-4" class="headerlink" title="输入样例"></a>输入样例</h4><p>5 5<br>C 1 2<br>Q1 1 2<br>Q2 1<br>C 2 5<br>Q2 5  </p><h4 id="输出样例-4"><a href="#输出样例-4" class="headerlink" title="输出样例"></a>输出样例</h4><p>Yes<br>2<br>3  </p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> p[M];<span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>[M];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">if</span>(p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);    <span class="hljs-keyword">return</span> p[x];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n,m;    <span class="hljs-built_in">cin</span> &gt;&gt;n&gt;&gt;m;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;=n;i++)        p[i] = i,<span class="hljs-built_in">size</span>[i] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(m--)&#123;        <span class="hljs-keyword">char</span> op[<span class="hljs-number">3</span>];        <span class="hljs-keyword">int</span> a,b;        <span class="hljs-built_in">cin</span> &gt;&gt;op;        <span class="hljs-keyword">if</span>(op[<span class="hljs-number">0</span>] == <span class="hljs-string">'C'</span>)&#123;            <span class="hljs-built_in">cin</span> &gt;&gt;a&gt;&gt;b;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(a) == <span class="hljs-built_in">find</span>(b)) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 若在同一集合则跳过</span>            <span class="hljs-built_in">size</span>[<span class="hljs-built_in">find</span>(b)] += <span class="hljs-built_in">size</span>[<span class="hljs-built_in">find</span>(a)];            p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span>(op[<span class="hljs-number">1</span>] == <span class="hljs-string">'1'</span>)&#123;                <span class="hljs-built_in">cin</span> &gt;&gt;a&gt;&gt;b;                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(a) == <span class="hljs-built_in">find</span>(b))&#123;                    <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">"Yes"</span>;                &#125;<span class="hljs-keyword">else</span>                    <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">"No"</span>;                <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">"\n"</span>;            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-built_in">cin</span> &gt;&gt;a;                <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-built_in">size</span>[<span class="hljs-built_in">find</span>(a)] &lt;&lt;<span class="hljs-string">'\n'</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="模拟堆"><a href="#模拟堆" class="headerlink" title="模拟堆"></a>模拟堆</h3><p>维护一个集合，初始时集合为空，支持如下几种操作：</p><p>“I x”，插入一个数x；<br>“PM”，输出当前集合中的最小值；<br>“DM”，删除当前集合中的最小值（数据保证此时的最小值唯一）；<br>“D k”，删除第k个插入的数；<br>“C k x”，修改第k个插入的数，将其变为x；<br>现在要进行N次操作，对于所有第2个操作，输出当前集合的最小值。</p><h4 id="输入格式-6"><a href="#输入格式-6" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数N。</p><p>接下来N行，每行包含一个操作指令，操作指令为”I x”，”PM”，”DM”，”D k”或”C k x”中的一种。</p><h4 id="输出格式-7"><a href="#输出格式-7" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个输出指令“PM”，输出一个结果，表示当前集合中的最小值。</p><p>每个结果占一行。</p><h4 id="数据范围-7"><a href="#数据范围-7" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤N≤105$<br>$−109≤x≤109$<br>数据保证合法。</p><h4 id="输入样例-5"><a href="#输入样例-5" class="headerlink" title="输入样例"></a>输入样例</h4><p>8<br>I -10<br>PM<br>I -10<br>D 1<br>C 2 8<br>I 6<br>PM<br>DM</p><h4 id="输出样例-5"><a href="#输出样例-5" class="headerlink" title="输出样例"></a>输出样例</h4><p>-10<br>6</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> h[M],<span class="hljs-built_in">size</span>;<span class="hljs-keyword">int</span> hp[M]; <span class="hljs-comment">// 堆中下标-&gt;插入下标</span><span class="hljs-keyword">int</span> ph[M]; <span class="hljs-comment">// 插入下标-&gt;堆中下标</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heap_swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;    swap(ph[hp[x]],ph[hp[y]]);    swap(hp[x],hp[y]);    swap(h[x],h[y]);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">int</span> t = x;    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span> * x &lt;= <span class="hljs-built_in">size</span> &amp;&amp; h[<span class="hljs-number">2</span> * x] &lt; h[t]) t = <span class="hljs-number">2</span> * x;    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span> * x + <span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">size</span> &amp;&amp; h[<span class="hljs-number">2</span> * x +<span class="hljs-number">1</span>] &lt; h[t]) t = <span class="hljs-number">2</span> * x + <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(x != t)&#123;        heap_swap(t,x);        down(t);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">while</span>(x/<span class="hljs-number">2</span> &amp;&amp; h[x/<span class="hljs-number">2</span>] &gt; h[x])&#123;        heap_swap(x/<span class="hljs-number">2</span>,x);        x/=<span class="hljs-number">2</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">cin</span> &gt;&gt; n;    <span class="hljs-built_in">string</span> op;    <span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(n--)&#123;        <span class="hljs-built_in">cin</span> &gt;&gt; op;        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">"I"</span>)&#123;            <span class="hljs-keyword">int</span> x;            <span class="hljs-built_in">cin</span> &gt;&gt; x;            h[++<span class="hljs-built_in">size</span>] = x;            ++m;            ph[m] = <span class="hljs-built_in">size</span>;            hp[<span class="hljs-built_in">size</span>] = m;            up(<span class="hljs-built_in">size</span>);        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">"PM"</span>)&#123;            <span class="hljs-built_in">cout</span> &lt;&lt; h[<span class="hljs-number">1</span>] &lt;&lt;<span class="hljs-string">"\n"</span>;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">"DM"</span>)&#123;            heap_swap(<span class="hljs-number">1</span>,<span class="hljs-built_in">size</span>);            <span class="hljs-built_in">size</span>--;            down(<span class="hljs-number">1</span>);        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">"D"</span>)&#123;            <span class="hljs-keyword">int</span> x;            <span class="hljs-built_in">cin</span> &gt;&gt; x;            x = ph[x];  <span class="hljs-comment">// 保存删除位置</span>            heap_swap(x,<span class="hljs-built_in">size</span>);            <span class="hljs-built_in">size</span>--;            down(x),up(x);        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">int</span> k,x;            <span class="hljs-built_in">cin</span> &gt;&gt; k &gt;&gt;x;            h[ph[k]] = x;            down(ph[k]),up(ph[k]);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="模拟散列表"><a href="#模拟散列表" class="headerlink" title="模拟散列表"></a>模拟散列表</h2><p>维护一个集合，支持如下几种操作：</p><p>“I x”，插入一个数x；<br>“Q x”，询问数x是否在集合中出现过；<br>现在要进行N次操作，对于每个询问操作输出对应的结果。</p><h4 id="输入格式-7"><a href="#输入格式-7" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数N，表示操作数量。</p><p>接下来N行，每行包含一个操作指令，操作指令为”I x”，”Q x”中的一种。</p><h4 id="输出格式-8"><a href="#输出格式-8" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个询问指令“Q x”，输出一个询问结果，如果x在集合中出现过，则输出“Yes”，否则输出“No”。</p><p>每个结果占一行。</p><h4 id="数据范围-8"><a href="#数据范围-8" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤N≤10^5$<br>$−109≤x≤10^9$</p><h4 id="输入样例-6"><a href="#输入样例-6" class="headerlink" title="输入样例"></a>输入样例</h4><p>5<br>I 1<br>I 2<br>I 3<br>Q 2<br>Q 5  </p><h4 id="输出样例-6"><a href="#输出样例-6" class="headerlink" title="输出样例"></a>输出样例</h4><p>Yes<br>No  </p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1e5</span> + <span class="hljs-number">3</span>;<span class="hljs-keyword">int</span> h[M],e[M],ne[M],idx;<span class="hljs-comment">// chining</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">int</span> hv = (x % M + M )%M;    e[idx] = x,ne[idx] = h[hv], h[hv] = idx++;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">int</span> hv = (x % M + M )%M;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = h[hv];i != <span class="hljs-number">-1</span>;i = ne[i])&#123;        <span class="hljs-keyword">if</span>(e[i] == x) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>)*M);    <span class="hljs-built_in">cin</span>.tie(<span class="hljs-number">0</span>);    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">cin</span> &gt;&gt; n;    <span class="hljs-keyword">char</span> op;    <span class="hljs-keyword">int</span> x;    <span class="hljs-keyword">while</span>(n--)&#123;        <span class="hljs-built_in">cin</span> &gt;&gt; op &gt;&gt; x;        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">'I'</span>) insert(x);        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(x)) <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">"Yes"</span>;            <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">"No"</span>;            <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">"\n"</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>给定一个n个点m条边的有向图，图中可能存在重边和自环。</p><p>请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出-1。</p><p>若一个由图中所有点构成的序列A满足：对于图中的每条边(x, y)，x在A中都出现在y之前，则称A是该图的一个拓扑序列。</p><h4 id="输入格式-8"><a href="#输入格式-8" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数n和m</p><p>接下来m行，每行包含两个整数x和y，表示存在一条从点x到点y的有向边(x, y)。</p><h4 id="输出格式-9"><a href="#输出格式-9" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，如果存在拓扑序列，则输出拓扑序列。</p><p>否则输出-1。</p><h4 id="数据范围-9"><a href="#数据范围-9" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤n,m≤10^5$  </p><h4 id="输入样例-7"><a href="#输入样例-7" class="headerlink" title="输入样例"></a>输入样例</h4><p>3 3<br>1 2<br>2 3<br>1 3  </p><h4 id="输出样例-7"><a href="#输出样例-7" class="headerlink" title="输出样例"></a>输出样例</h4><p>1 2 3</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> h[M],e[M],ne[M],idx;<span class="hljs-keyword">int</span> n,m;<span class="hljs-keyword">int</span> q[M],d[M];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;    e[idx] = b,ne[idx] = h[a],h[a] = idx++;&#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> hh =<span class="hljs-number">0</span> ,tt = <span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)        <span class="hljs-keyword">if</span>(!d[i]) q[++tt] = i;    <span class="hljs-keyword">while</span>(hh &lt;= tt)&#123;        <span class="hljs-keyword">int</span> t = q[hh++];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = h[t];i != <span class="hljs-number">-1</span>;i = ne[i])&#123;            <span class="hljs-keyword">int</span> j = e[i];            d[j] --;            <span class="hljs-keyword">if</span>(!d[j]) q[++tt] = j;        &#125;    &#125;    <span class="hljs-keyword">return</span> tt == n<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">cin</span>.tie(<span class="hljs-number">0</span>);    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-built_in">cin</span> &gt;&gt; n&gt;&gt;m;    <span class="hljs-keyword">int</span> a,b;    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(h));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)&#123;        <span class="hljs-built_in">cin</span> &gt;&gt; a&gt;&gt; b;        add(a,b);        d[b] ++;    &#125;    <span class="hljs-keyword">if</span>(topsort())&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)            <span class="hljs-built_in">cout</span> &lt;&lt; q[i] &lt;&lt;<span class="hljs-string">" "</span>;    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">"-1"</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><h3 id="朴素Dijkstra-O-n-2"><a href="#朴素Dijkstra-O-n-2" class="headerlink" title="朴素Dijkstra $O(n^2)$"></a>朴素Dijkstra $O(n^2)$</h3><ul><li>没有负权边</li><li>稠密图 $m &lt; n^2$<br>给定一个n个点m条边的有向图，图中可能存在重边和自环，所有边权均为正值。</li></ul><p>请你求出1号点到n号点的最短距离，如果无法从1号点走到n号点，则输出-1。</p><h4 id="输入格式-9"><a href="#输入格式-9" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数n和m。</p><p>接下来m行每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。</p><h4 id="输出格式-10"><a href="#输出格式-10" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示1号点到n号点的最短距离。</p><p>如果路径不存在，则输出-1。</p><h4 id="数据范围-10"><a href="#数据范围-10" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤n≤500,$<br>$1≤m≤105,$<br>图中涉及边长均不超过10000。</p><h4 id="输入样例-8"><a href="#输入样例-8" class="headerlink" title="输入样例"></a>输入样例</h4><p>3 3<br>1 2 2<br>2 3 1<br>1 3 4  </p><h4 id="输出样例-8"><a href="#输出样例-8" class="headerlink" title="输出样例"></a>输出样例</h4><p>3</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">510</span>;<span class="hljs-keyword">int</span> g[M][M],d[M];<span class="hljs-keyword">int</span> n,m;<span class="hljs-keyword">bool</span> st[M];<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x7f7f7f7f</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">djstra</span><span class="hljs-params">()</span></span>&#123;    d[<span class="hljs-number">1</span>] =<span class="hljs-number">0</span> ;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;=n;i++)&#123;        <span class="hljs-keyword">int</span> t = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt;=n;j++)&#123;            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || d[j] &lt; d[t])) t = j;        &#125;        st[t] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt;=n; j++)&#123;            <span class="hljs-keyword">if</span>(g[t][j] != INF) d[j] = <span class="hljs-built_in">min</span>(d[j],d[t] + g[t][j]);        &#125;    &#125;    <span class="hljs-keyword">if</span>(d[n] == INF) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> d[n];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x7f</span>,<span class="hljs-keyword">sizeof</span>(g));    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x7f</span>,<span class="hljs-keyword">sizeof</span>(d));    <span class="hljs-keyword">int</span> a,b,c;    <span class="hljs-keyword">while</span>(m--)&#123;        <span class="hljs-built_in">cin</span> &gt;&gt; a&gt;&gt; b&gt;&gt; c;        g[a][b] = <span class="hljs-built_in">min</span>(g[a][b],c);    &#125;    <span class="hljs-built_in">cout</span> &lt;&lt; djstra();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="堆优化Dijkstra-O-mlogn"><a href="#堆优化Dijkstra-O-mlogn" class="headerlink" title="堆优化Dijkstra $O(mlogn)$"></a>堆优化Dijkstra $O(mlogn)$</h3><ul><li>没有负权边</li><li>稀疏图<br>给定一个n个点m条边的有向图，图中可能存在重边和自环，所有边权均为非负值。</li></ul><p>请你求出1号点到n号点的最短距离，如果无法从1号点走到n号点，则输出-1。</p><h4 id="输入格式-10"><a href="#输入格式-10" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数n和m。</p><p>接下来m行每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。</p><h4 id="输出格式-11"><a href="#输出格式-11" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示1号点到n号点的最短距离。</p><p>如果路径不存在，则输出-1。</p><h4 id="数据范围-11"><a href="#数据范围-11" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤n,m≤105,$<br>图中涉及边长均不小于0，且不超过10000。</p><h4 id="输入样例-9"><a href="#输入样例-9" class="headerlink" title="输入样例"></a>输入样例</h4><p>3 3<br>1 2 2<br>2 3 1<br>1 3 4  </p><h4 id="输出样例-9"><a href="#输出样例-9" class="headerlink" title="输出样例"></a>输出样例</h4><p>3</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> h[M],e[M],ne[M],idx,w[M];<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> c)</span></span>&#123;    e[idx] = b,w[idx] = c,ne[idx] = h[a],h[a] = idx++;&#125;<span class="hljs-keyword">int</span> n,m;<span class="hljs-keyword">int</span> d[M];<span class="hljs-keyword">bool</span> st[M];<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x7f7f7f7f</span><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; PII;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">djs</span><span class="hljs-params">()</span></span>&#123;    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    priority_queue&lt;PII,<span class="hljs-built_in">vector</span>&lt;PII&gt;,greater&lt;PII&gt;&gt; pq;    pq.push(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);    <span class="hljs-keyword">while</span>(pq.<span class="hljs-built_in">size</span>())&#123;        <span class="hljs-keyword">auto</span> t= pq.top();pq.pop();        <span class="hljs-keyword">if</span>(st[t.second]) <span class="hljs-keyword">continue</span>;        st[t.second] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = h[t.second]; i != <span class="hljs-number">-1</span>;i = ne[i])&#123;            <span class="hljs-keyword">int</span> j = e[i];            <span class="hljs-keyword">if</span>(d[j] &gt; d[t.second] + w[i])&#123;                d[j] = d[t.second] + w[i];                pq.push(&#123;d[j],j&#125;);            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span>(d[n] == INF) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> d[n];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">cin</span>.tie(<span class="hljs-number">0</span>);    ios::sync_with_stdio(<span class="hljs-literal">false</span>);    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">int</span> a,b,c;    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(h));    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x7f</span>,<span class="hljs-keyword">sizeof</span>(d));    <span class="hljs-keyword">while</span>(m--)&#123;        <span class="hljs-built_in">cin</span>&gt;&gt; a&gt;&gt; b&gt;&gt; c;        add(a,b,c);    &#125;    <span class="hljs-built_in">cout</span> &lt;&lt; djs();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="B-F算法-O-nm"><a href="#B-F算法-O-nm" class="headerlink" title="B-F算法 $O(nm)$"></a>B-F算法 $O(nm)$</h3><ul><li>允许负权边</li><li>用于求限制k条边的最短路</li></ul><p>给定一个n个点m条边的有向图，图中可能存在重边和自环， 边权可能为负数。</p><p>请你求出从1号点到n号点的最多经过k条边的最短距离，如果无法从1号点走到n号点，输出impossible。</p><p>注意：图中可能 存在负权回路 。</p><h4 id="输入格式-11"><a href="#输入格式-11" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含三个整数n，m，k。</p><p>接下来m行，每行包含三个整数x，y，z，表示存在一条从点x到点y的有向边，边长为z。</p><h4 id="输出格式-12"><a href="#输出格式-12" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示从1号点到n号点的最多经过k条边的最短距离。</p><p>如果不存在满足条件的路径，则输出“impossible”。</p><h4 id="数据范围-12"><a href="#数据范围-12" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤n,k≤500,$<br>$1≤m≤10000,$<br>任意边长的绝对值不超过10000。</p><h4 id="输入样例-10"><a href="#输入样例-10" class="headerlink" title="输入样例"></a>输入样例</h4><p>3 3 1<br>1 2 1<br>2 3 1<br>1 3 3</p><h4 id="输出样例-10"><a href="#输出样例-10" class="headerlink" title="输出样例"></a>输出样例</h4><p>3</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span>    <span class="hljs-keyword">int</span> a,b,w;&#125;edges[M];<span class="hljs-keyword">int</span> n,m,k;<span class="hljs-keyword">bool</span> st[N];<span class="hljs-keyword">int</span> d[N];<span class="hljs-keyword">int</span> backup[N]; <span class="hljs-comment">// 备份上一次循环的结果</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bf</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x7f</span>,<span class="hljs-keyword">sizeof</span>(d));    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; k;i++)&#123;        <span class="hljs-built_in">memcpy</span>(backup,d,<span class="hljs-keyword">sizeof</span>(d));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt;m;j++)&#123;            <span class="hljs-comment">// 使用上一次循环结果更新， 防止连续更新</span>            <span class="hljs-keyword">if</span>(d[edges[j].b] &gt; backup[edges[j].a] + edges[j].w)&#123;                d[edges[j].b] = backup[edges[j].a] + edges[j].w;            &#125;        &#125;    &#125;    <span class="hljs-comment">// 由于负权边 d[n] 可能比INF小</span>    <span class="hljs-keyword">if</span>(d[n] &gt; <span class="hljs-number">0x7f7f7f7f</span> /<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> d[n];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m&gt;&gt;k;    <span class="hljs-keyword">int</span> a,b,c;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)&#123;        <span class="hljs-built_in">cin</span> &gt;&gt; a&gt;&gt; b &gt;&gt; c;        edges[i] = &#123;a,b,c&#125;;    &#125;    <span class="hljs-keyword">int</span> res = bf();    <span class="hljs-keyword">if</span>(res == <span class="hljs-number">-1</span>) <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">"impossible"</span>;    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; res;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="spfa-平均-O-m-最坏-O-nm"><a href="#spfa-平均-O-m-最坏-O-nm" class="headerlink" title="spfa 平均$O(m)$ 最坏$O(nm)$"></a>spfa 平均$O(m)$ 最坏$O(nm)$</h3><blockquote><p>bf算法每次遍历所有边，spfa仅更新距离发生变化的边</p></blockquote><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> h[M],e[M],ne[M],w[M],idx;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> c)</span></span>&#123;    e[idx] = b,w[idx] = c,ne[idx] = h[a],h[a] = idx ++;&#125;<span class="hljs-keyword">int</span> n,m;<span class="hljs-keyword">int</span> d[M];<span class="hljs-keyword">bool</span> st[M];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x7f</span>,<span class="hljs-keyword">sizeof</span>(d));    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;    q.push(<span class="hljs-number">1</span>);    st[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;        <span class="hljs-keyword">int</span> t = q.front();        q.pop();        st[t] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = h[t];i != <span class="hljs-number">-1</span>;i = ne[i])&#123;            <span class="hljs-keyword">int</span> j = e[i];            <span class="hljs-keyword">if</span>(d[j] &gt; d[t] + w[i])&#123;                d[j] = d[t] + w[i];                <span class="hljs-keyword">if</span>(!st[j]) &#123;                    st[j] = <span class="hljs-number">1</span>;                    q.push(j);                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span>(d[n] &gt; <span class="hljs-number">0x7f7f7f7f</span> /<span class="hljs-number">2</span> ) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> d[n];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(h));    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">int</span> a,b,c;    <span class="hljs-keyword">while</span>(m--)&#123;        <span class="hljs-built_in">cin</span> &gt;&gt; a&gt;&gt;b&gt;&gt;c;        add(a,b,c);    &#125;    <span class="hljs-keyword">int</span> res = spfa();    <span class="hljs-keyword">if</span>(res == <span class="hljs-number">-1</span>) <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">"impossible"</span>;    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; res;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="朴素prim-O-n-2"><a href="#朴素prim-O-n-2" class="headerlink" title="朴素prim  $O(n^2)$"></a>朴素prim  $O(n^2)$</h3><ul><li>用于稠密图</li></ul><p>给定一个n个点m条边的无向图，图中可能存在重边和自环，边权可能为负数。</p><p>求最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。</p><p>给定一张边带权的无向图G=(V, E)，其中V表示图中点的集合，E表示图中边的集合，n=|V|，m=|E|。</p><p>由V中的全部n个顶点和E中n-1条边构成的无向连通子图被称为G的一棵生成树，其中边的权值之和最小的生成树被称为无向图G的最小生成树。</p><h4 id="输入格式-12"><a href="#输入格式-12" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数n和m。</p><p>接下来m行，每行包含三个整数u，v，w，表示点u和点v之间存在一条权值为w的边。</p><h4 id="输出格式-13"><a href="#输出格式-13" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。</p><h4 id="数据范围-13"><a href="#数据范围-13" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤n≤500,$<br>$1≤m≤105,$<br>图中涉及边的边权的绝对值均不超过10000。</p><h4 id="输入样例-11"><a href="#输入样例-11" class="headerlink" title="输入样例"></a>输入样例</h4><p>4 5<br>1 2 1<br>1 3 2<br>1 4 3<br>2 3 2<br>3 4 4  </p><h4 id="输出样例-11"><a href="#输出样例-11" class="headerlink" title="输出样例"></a>输出样例</h4><p>6</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">510</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF =<span class="hljs-number">0x7f7f7f7f</span>;<span class="hljs-keyword">int</span> g[M][M];<span class="hljs-keyword">int</span> n,m;<span class="hljs-keyword">int</span> d[M];<span class="hljs-keyword">bool</span> st[M];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 循环n次，每次加入一个点到mst集合</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; n;i++)&#123;        <span class="hljs-keyword">int</span> t = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j&lt;=n;j++)&#123;            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || d[j] &lt; d[t])) t =  j;        &#125;        <span class="hljs-keyword">if</span>(i &amp;&amp; d[t] == INF) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;         st[t] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(i) res += d[t];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt;=n;j++)&#123;            <span class="hljs-keyword">if</span>(g[t][j] != INF)&#123;                d[j] = <span class="hljs-built_in">min</span>(d[j],g[t][j]);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x7f</span>,<span class="hljs-keyword">sizeof</span> d);    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;=n;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt;=n;j++)            <span class="hljs-keyword">if</span>(i == j) g[i][j] = <span class="hljs-number">0</span>;            <span class="hljs-keyword">else</span> g[i][j] = INF;    <span class="hljs-keyword">int</span> a,b,c;    <span class="hljs-keyword">while</span>(m--)&#123;        <span class="hljs-built_in">cin</span> &gt;&gt; a&gt;&gt;b&gt;&gt;c;        g[a][b] = g[b][a] = <span class="hljs-built_in">min</span>(g[a][b],c);    &#125;    <span class="hljs-keyword">int</span> res = prim();    <span class="hljs-keyword">if</span>(res == <span class="hljs-number">-1</span>) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"impossible"</span>;    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; res;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="克鲁斯卡尔-O-mlogm"><a href="#克鲁斯卡尔-O-mlogm" class="headerlink" title="克鲁斯卡尔 $O(mlogm)$"></a>克鲁斯卡尔 $O(mlogm)$</h3><ul><li>用于稀疏图<br>给定一个n个点m条边的无向图，图中可能存在重边和自环，边权可能为负数。</li></ul><p>求最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。</p><p>给定一张边带权的无向图G=(V, E)，其中V表示图中点的集合，E表示图中边的集合，n=|V|，m=|E|。</p><p>由V中的全部n个顶点和E中n-1条边构成的无向连通子图被称为G的一棵生成树，其中边的权值之和最小的生成树被称为无向图G的最小生成树。</p><h4 id="输入格式-13"><a href="#输入格式-13" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数n和m。</p><p>接下来m行，每行包含三个整数u，v，w，表示点u和点v之间存在一条权值为w的边。</p><h4 id="输出格式-14"><a href="#输出格式-14" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。</p><h4 id="数据范围-14"><a href="#数据范围-14" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤n≤105,$<br>$1≤m≤2∗105,$<br>图中涉及边的边权的绝对值均不超过1000。</p><h4 id="输入样例-12"><a href="#输入样例-12" class="headerlink" title="输入样例"></a>输入样例</h4><p>4 5<br>1 2 1<br>1 3 2<br>1 4 3<br>2 3 2<br>3 4 4  </p><h4 id="输出样例-12"><a href="#输出样例-12" class="headerlink" title="输出样例"></a>输出样例</h4><p>6</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span>    <span class="hljs-keyword">int</span> a,b,w;    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-keyword">const</span> Edge&amp; e)&#123;        <span class="hljs-keyword">return</span> w &lt; e.w;    &#125;&#125;e[M];<span class="hljs-keyword">int</span> n,m;<span class="hljs-keyword">int</span> p[M];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">if</span>(p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);    <span class="hljs-keyword">return</span> p[x];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;=n;i++)        p[i] = i;    <span class="hljs-keyword">int</span> a,b,c;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m;i++)&#123;        <span class="hljs-built_in">cin</span> &gt;&gt; a&gt;&gt;b&gt;&gt;c;        e[i] = &#123;a,b,c&#125;;    &#125;    sort(e,e + m);    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>,cnt = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)&#123;        a = <span class="hljs-built_in">find</span>(e[i].a),b = <span class="hljs-built_in">find</span>(e[i].b);        <span class="hljs-keyword">if</span>(a != b)&#123;            p[a] = b;            cnt ++;            res += e[i].w;        &#125;;    &#125;    <span class="hljs-keyword">if</span>(cnt != n<span class="hljs-number">-1</span>) <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">"impossible"</span>;    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt; res;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><ul><li>充要条件: 没有奇数环</li></ul><h3 id="染色法判定二分图"><a href="#染色法判定二分图" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h3><p>给定一个n个点m条边的无向图，图中可能存在重边和自环。</p><p>请你判断这个图是否是二分图。</p><h4 id="输入格式-14"><a href="#输入格式-14" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数n和m。</p><p>接下来m行，每行包含两个整数u和v，表示点u和点v之间存在一条边。</p><h4 id="输出格式-15"><a href="#输出格式-15" class="headerlink" title="输出格式"></a>输出格式</h4><p>如果给定图是二分图，则输出“Yes”，否则输出“No”。</p><h4 id="数据范围-15"><a href="#数据范围-15" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤n,m≤10^5$</p><h4 id="输入样例-13"><a href="#输入样例-13" class="headerlink" title="输入样例"></a>输入样例</h4><p>4 4<br>1 3<br>1 4<br>2 3<br>2 4</p><h4 id="输出样例-13"><a href="#输出样例-13" class="headerlink" title="输出样例"></a>输出样例</h4><p>Yes</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> h[M],e[M],ne[M],idx;<span class="hljs-keyword">int</span> color[M];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;    e[idx] = b,ne[idx] = h[a],h[a] = idx++;&#125;<span class="hljs-keyword">int</span> n,m;<span class="hljs-comment">// 将点u染成c色</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> c)</span></span>&#123;    color[u] = c;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = h[u];i !=<span class="hljs-number">-1</span>;i = ne[i])&#123;        <span class="hljs-keyword">int</span> j = e[i];        <span class="hljs-keyword">if</span>(!color[j])&#123;            <span class="hljs-keyword">if</span>(!dfs(j,<span class="hljs-number">3</span> - c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(color[j] == c) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);    <span class="hljs-built_in">cin</span> &gt;&gt; n&gt;&gt;m;    <span class="hljs-keyword">int</span> a,b;    <span class="hljs-keyword">while</span>(m--)&#123;        <span class="hljs-built_in">cin</span> &gt;&gt; a&gt;&gt;b;        add(a,b),add(b,a);    &#125;    <span class="hljs-keyword">bool</span> res = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(!color[i])&#123;            <span class="hljs-keyword">if</span>(!dfs(i,<span class="hljs-number">1</span>))&#123;                res = <span class="hljs-literal">false</span>;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span>(res) <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Yes"</span>;    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">"No"</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="最大匹配"><a href="#最大匹配" class="headerlink" title="最大匹配"></a>最大匹配</h3><p>给定一个二分图，其中左半部包含n1个点（编号1~n1），右半部包含n2个点（编号1~n2），二分图共包含m条边。</p><p>数据保证任意一条边的两个端点都不可能在同一部分中。</p><p>请你求出二分图的最大匹配数。</p><blockquote><p>二分图的匹配：给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。<br>二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。</p></blockquote><h4 id="输入格式-15"><a href="#输入格式-15" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含三个整数 n1、 n2 和 m。</p><p>接下来m行，每行包含两个整数u和v，表示左半部点集中的点u和右半部点集中的点v之间存在一条边。</p><h4 id="输出格式-16"><a href="#输出格式-16" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示二分图的最大匹配数。</p><h4 id="数据范围-16"><a href="#数据范围-16" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤n1,n2≤500,$<br>$1≤u≤n1,$<br>$1≤v≤n2,$<br>$1≤m≤10^5$</p><h4 id="输入样例-14"><a href="#输入样例-14" class="headerlink" title="输入样例"></a>输入样例</h4><p>2 2 4<br>1 1<br>1 2<br>2 1<br>2 2</p><h4 id="输出样例-14"><a href="#输出样例-14" class="headerlink" title="输出样例"></a>输出样例</h4><p>2</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">510</span>,M = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> h[M],e[M],ne[M],idx;<span class="hljs-keyword">int</span> n1,n2,m;<span class="hljs-keyword">bool</span> st[N];<span class="hljs-keyword">int</span> match[N];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;    e[idx] = b,ne[idx]= h[a],h[a] = idx++;&#125;<span class="hljs-comment">// 为x找到对应点</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = h[x]; i != <span class="hljs-number">-1</span>; i = ne[i])&#123;        <span class="hljs-keyword">int</span> j = e[i];        <span class="hljs-keyword">if</span>(!st[j])&#123; <span class="hljs-comment">// 女生j没有访问过</span>            st[j] = <span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(match[j] == <span class="hljs-number">0</span> || <span class="hljs-built_in">find</span>(match[j]))&#123; <span class="hljs-comment">// 女生j没有男友或给j的男友找到新的女友</span>                match[j] = x;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);    <span class="hljs-built_in">cin</span> &gt;&gt; n1&gt;&gt; n2&gt;&gt;m;    <span class="hljs-keyword">int</span> a,b;    <span class="hljs-keyword">while</span>(m--)&#123;        <span class="hljs-built_in">cin</span> &gt;&gt; a&gt;&gt;b;        add(a,b);    &#125;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;=n1;i++)&#123;        <span class="hljs-built_in">memset</span>(st,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> st); <span class="hljs-comment">// 将女生初始化，每个女生仅访问一次</span>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(i)) res++;    &#125;    <span class="hljs-built_in">cout</span> &lt;&lt; res;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="简单数学"><a href="#简单数学" class="headerlink" title="简单数学"></a>简单数学</h2><ul><li>对于正整数n，仅有一个大于$\sqrt{n}$的素数</li></ul><h3 id="筛素数"><a href="#筛素数" class="headerlink" title="筛素数"></a>筛素数</h3><h4 id="埃氏筛法-O-nloglogn"><a href="#埃氏筛法-O-nloglogn" class="headerlink" title="埃氏筛法 $O(nloglogn)$"></a>埃氏筛法 $O(nloglogn)$</h4><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1e6</span>+ <span class="hljs-number">10</span>;<span class="hljs-keyword">bool</span> st[M];<span class="hljs-keyword">int</span> prime[M];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">cin</span> &gt;&gt; n;    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">2</span>;i &lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(!st[i])&#123;            prime[cnt++];            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i;j &lt;=n;j +=i) <span class="hljs-comment">// 筛掉i的倍数</span>                st[j] = <span class="hljs-literal">true</span>;        &#125;    &#125;    <span class="hljs-built_in">cout</span> &lt;&lt; cnt;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="线性筛法-O-n"><a href="#线性筛法-O-n" class="headerlink" title="线性筛法 $O(n)$"></a>线性筛法 $O(n)$</h4><ul><li>x只会被最小质因子筛掉</li></ul><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1e6</span>+ <span class="hljs-number">10</span>;<span class="hljs-keyword">bool</span> st[M];<span class="hljs-keyword">int</span> prime[M];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">cin</span> &gt;&gt; n;    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">2</span>;i &lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(!st[i]) prime[cnt++] = i;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;prime[j] &lt;= n/i;j++)&#123;            st[prime[j] * i] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// prime[j] 小于i的所有质因子，则prime[j] 为 prime[j]*i 的最小质因子</span>            <span class="hljs-keyword">if</span>(i % prime[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// prime[j] 是i的最小质因子,因此，prime[j] 是i*prime[j] 的最小质因子</span>        &#125;    &#125;    <span class="hljs-built_in">cout</span> &lt;&lt; cnt;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h3><h4 id="求约数-O-n-sqrt-n"><a href="#求约数-O-n-sqrt-n" class="headerlink" title="求约数 $O(n\sqrt{n})$"></a>求约数 $O(n\sqrt{n})$</h4><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; p;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">cin</span> &gt;&gt; n;    <span class="hljs-keyword">int</span> x;    <span class="hljs-keyword">while</span>(n--)&#123;        <span class="hljs-built_in">cin</span> &gt;&gt; x;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= x/i;i++)&#123;            <span class="hljs-keyword">if</span>(x % i == <span class="hljs-number">0</span>)&#123;                p.push_back(i);                <span class="hljs-keyword">if</span>(i != x/i)p.push_back(x/i);            &#125;        &#125;        sort(p.<span class="hljs-built_in">begin</span>(),p.<span class="hljs-built_in">end</span>());        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> a : p)            <span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt;<span class="hljs-string">" "</span>;        <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">"\n"</span>;        p.<span class="hljs-built_in">clear</span>();    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><script type="math/tex; mode=display">算数基本定理:N=\prod_{i=1}p_i^{\alpha_i}</script><h4 id="约数个数"><a href="#约数个数" class="headerlink" title="约数个数"></a>约数个数</h4><blockquote><p>$[1,n]$中约数的个数等于每个数倍数的个数$\sum_{i=1}^{n}{\frac{n}{i}} = nlnn$</p><script type="math/tex; mode=display">\prod_{i=1}^{n}(\alpha_i+1)</script></blockquote><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod = <span class="hljs-number">1e9</span> +<span class="hljs-number">7</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">map</span>;    <span class="hljs-built_in">cin</span> &gt;&gt; n;    <span class="hljs-keyword">long</span> res = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(n--)&#123;        <span class="hljs-keyword">int</span> x;        <span class="hljs-built_in">cin</span> &gt;&gt; x;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt;=x/i;i++)&#123;            <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span>(x % i == <span class="hljs-number">0</span>)&#123;                x/=i;                cnt ++;            &#125;            <span class="hljs-keyword">if</span>(cnt) <span class="hljs-built_in">map</span>[i] += cnt;        &#125;        <span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">1</span>) <span class="hljs-built_in">map</span>[x] += <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> a : <span class="hljs-built_in">map</span>)&#123;        res = res *(a.second + <span class="hljs-number">1</span>) %mod;    &#125;    <span class="hljs-built_in">cout</span> &lt;&lt; res;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="约数之和"><a href="#约数之和" class="headerlink" title="约数之和"></a>约数之和</h4><script type="math/tex; mode=display">\prod_{i=1}^{n}\sum_{j=0}p_i^{\alpha_j}</script><p>给定n个正整数ai，请你输出这些数的乘积的约数之和，答案对109+7取模。</p><h4 id="输入格式-16"><a href="#输入格式-16" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数n。</p><p>接下来n行，每行包含一个整数ai。</p><h4 id="输出格式-17"><a href="#输出格式-17" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示所给正整数的乘积的约数之和，答案需对109+7取模。</p><h4 id="数据范围-17"><a href="#数据范围-17" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤n≤100,$<br>$1≤ai≤2∗109$</p><h4 id="输入样例-15"><a href="#输入样例-15" class="headerlink" title="输入样例"></a>输入样例</h4><p>3<br>2<br>6<br>8</p><h4 id="输出样例-15"><a href="#输出样例-15" class="headerlink" title="输出样例"></a>输出样例</h4><p>252</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">map</span>;    <span class="hljs-keyword">long</span> res = <span class="hljs-number">1</span>;    <span class="hljs-built_in">cin</span> &gt;&gt; n;    <span class="hljs-keyword">while</span>(n--)&#123;        <span class="hljs-keyword">int</span> x;        <span class="hljs-built_in">cin</span> &gt;&gt; x;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt;= x/i;i++)&#123;            <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span>(x % i == <span class="hljs-number">0</span>)&#123;                x/=i;                cnt ++;            &#125;            <span class="hljs-keyword">if</span>(cnt) <span class="hljs-built_in">map</span>[i] += cnt;        &#125;        <span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">1</span>) <span class="hljs-built_in">map</span>[x] += <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t : <span class="hljs-built_in">map</span>)&#123;        <span class="hljs-keyword">long</span> p = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> a = t.first,b = t.second;        <span class="hljs-keyword">while</span>(b--)&#123;            p = (p * a + <span class="hljs-number">1</span>)%mod;        &#125;        res = res * p %mod;    &#125;    <span class="hljs-built_in">cout</span> &lt;&lt; res;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h4><ul><li>if d/a,d/b then d/(ax+by)</li></ul><blockquote><p>$gcd(a,b) = gcd(b,a\ mod \ b)$<br>$gcd(a,b) = gcd(a - c<em>b)$<br>$d/a,d/b-&gt;d/(a-c</em>b)-&gt;d/(a-d<em>b+c</em>b)$<br>公约数集合相同  </p></blockquote><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><ul><li>互质是公约数只有1的两个整数</li></ul><blockquote><p>$\phi(n):[1,n]中与n互质的数的个数$<br>给定n个正整数ai，请你求出每个数的欧拉函数。</p></blockquote><h4 id="欧拉函数的定义"><a href="#欧拉函数的定义" class="headerlink" title="欧拉函数的定义"></a>欧拉函数的定义</h4><p>1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)。<br>若在算数基本定理中， N=pa11pa22…pamm ，则：<br>ϕ(N) = N∗p1−1p1∗p2−1p2∗…∗pm−1pm</p><h4 id="输入格式-17"><a href="#输入格式-17" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数n。</p><p>接下来n行，每行包含一个正整数ai。</p><h4 id="输出格式-18"><a href="#输出格式-18" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出共n行，每行输出一个正整数ai的欧拉函数。</p><h4 id="数据范围-18"><a href="#数据范围-18" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤n≤100,$<br>$1≤ai≤2∗10^9$</p><h4 id="输入样例-16"><a href="#输入样例-16" class="headerlink" title="输入样例"></a>输入样例</h4><p>3<br>3<br>6<br>8</p><h4 id="输出样例-16"><a href="#输出样例-16" class="headerlink" title="输出样例"></a>输出样例</h4><p>2<br>2<br>4</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">cin</span> &gt;&gt; n;    <span class="hljs-keyword">while</span>(n--)&#123;        <span class="hljs-keyword">int</span> x;        <span class="hljs-built_in">cin</span> &gt;&gt; x;        <span class="hljs-keyword">int</span> res = x;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt;=x/i;i++)            <span class="hljs-keyword">if</span>(x % i == <span class="hljs-number">0</span>)&#123;                res = res / i * (i - <span class="hljs-number">1</span>);                <span class="hljs-keyword">while</span>(x % i == <span class="hljs-number">0</span>)&#123;                    x/=i;                &#125;            &#125;        <span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">1</span>) res = res /x*(x<span class="hljs-number">-1</span>);        <span class="hljs-built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="筛法求欧拉函数"><a href="#筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数"></a>筛法求欧拉函数</h3><p>给定一个正整数n，求1~n中每个数的欧拉函数之和。</p><h4 id="输入格式-18"><a href="#输入格式-18" class="headerlink" title="输入格式"></a>输入格式</h4><p>共一行，包含一个整数n。</p><h4 id="输出格式-19"><a href="#输出格式-19" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含一个整数，表示1~n中每个数的欧拉函数之和。</p><h4 id="数据范围-19"><a href="#数据范围-19" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤n≤10^6$</p><h4 id="输入样例-17"><a href="#输入样例-17" class="headerlink" title="输入样例"></a>输入样例</h4><p>6</p><h4 id="输出样例-17"><a href="#输出样例-17" class="headerlink" title="输出样例"></a>输出样例</h4><p>12</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<span class="hljs-keyword">bool</span> st[M];<span class="hljs-keyword">int</span> primes[M];<span class="hljs-keyword">int</span> cnt;<span class="hljs-keyword">int</span> phi[M];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">cin</span> &gt;&gt; n;    phi[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt;=n;i++)&#123;        <span class="hljs-keyword">if</span>(!st[i])&#123;            primes[cnt++] = i;            phi[i] = i<span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;primes[j]&lt;=n/i;j++)&#123;            st[primes[j] * i] = <span class="hljs-literal">true</span>;            <span class="hljs-keyword">if</span>(i % primes[j] == <span class="hljs-number">0</span>)&#123;                <span class="hljs-comment">// primes[j] 为i的质因子</span>                phi[i * primes[j]] = phi[i]*primes[j];                <span class="hljs-keyword">break</span>;            &#125;            phi[i * primes[j]] = phi[i]*(primes[j] - <span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i &lt;=n;i++) res += phi[i];    <span class="hljs-built_in">cout</span> &lt;&lt; res;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>$a,n互质,a^{\phi(n)}\equiv1(mod\ n)$</p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>$let\ [1,n]中与n互质的数为a<em>1,a_2,…,a</em>{\phi(n)}$<br>$则aa<em>1,aa_2,…,aa</em>{\phi(n)}\ mod\ n 与a<em>1,a_2,…a</em>{\phi(n)}为同一集合$  </p><blockquote><p>反证：若$aa<em>i=aa_j,则a(a_i-a_j)\equiv0(mod\ n),且a与n互质，则a_i=a_j,矛盾$<br>$a^{\phi(n)}(a_1a_2…a</em>{\phi(n)})\equiv(a<em>1a_2…a</em>{\phi(n)}) (mod\ n)$<br>$则a^{\phi(n)}\equiv1(mod\ n)$  </p></blockquote><h3 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h3><p>给定n对正整数ai,bi，对于每对数，求出一组xi,yi，使其满足ai∗xi+bi∗yi=gcd(ai,bi)。</p><blockquote><p>$d = gcd(b,a-\lfloor{\frac{a}{b}}\rfloor<em>b,y,x)$<br>$即:x(a-\lfloor{\frac{a}{b}}\rfloor</em>b)+by = d$<br>$xa+(y-\lfloor{\frac{a}{b}}\rfloor*x) = d$</p></blockquote><h4 id="输入格式-19"><a href="#输入格式-19" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数n。</p><p>接下来n行，每行包含两个整数ai,bi。</p><h4 id="输出格式-20"><a href="#输出格式-20" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出共n行，对于每组ai,bi，求出一组满足条件的xi,yi，每组结果占一行。</p><p>本题答案不唯一，输出任意满足条件的xi,yi均可。</p><h4 id="数据范围-20"><a href="#数据范围-20" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤105,<br>1≤ai,bi≤2∗109</p><h4 id="输入样例-18"><a href="#输入样例-18" class="headerlink" title="输入样例"></a>输入样例</h4><p>2<br>4 6<br>8 18 </p><h4 id="输出样例-18"><a href="#输出样例-18" class="headerlink" title="输出样例"></a>输出样例</h4><p>-1 1<br>-2 1  </p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span>&amp;x,<span class="hljs-keyword">int</span>&amp;y)</span></span>&#123;    <span class="hljs-keyword">if</span>(!b)&#123;        x = <span class="hljs-number">1</span>,y= <span class="hljs-number">0</span>;         <span class="hljs-keyword">return</span> a;    &#125;    <span class="hljs-keyword">int</span> d = exgcd(b,a%b,y,x);    y -= a/b*x;    <span class="hljs-keyword">return</span> d;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">cin</span> &gt;&gt; n;    <span class="hljs-keyword">while</span>(n--)&#123;        <span class="hljs-keyword">int</span> a,b,x,y;        <span class="hljs-built_in">cin</span> &gt;&gt; a&gt;&gt;b;        exgcd(a,b,x,y);        <span class="hljs-built_in">cout</span> &lt;&lt; x&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;y&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><p>输入一个包含n个方程n个未知数的线性方程组。</p><p>方程组中的系数为实数。</p><p>求解这个方程组。</p><h4 id="输入格式-20"><a href="#输入格式-20" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数n。</p><p>接下来n行，每行包含n+1个实数，表示一个方程的n个系数以及等号右侧的常数。</p><h4 id="输出格式-21"><a href="#输出格式-21" class="headerlink" title="输出格式"></a>输出格式</h4><p>如果给定线性方程组存在唯一解，则输出共n行，其中第i行输出第i个未知数的解，结果保留两位小数。</p><p>如果给定线性方程组存在无数解，则输出“Infinite group solutions”。</p><p>如果给定线性方程组无解，则输出“No solution”。</p><h4 id="数据范围-21"><a href="#数据范围-21" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤100,<br>所有输入系数以及常数均保留两位小数，绝对值均不超过100。</p><h4 id="输入样例-19"><a href="#输入样例-19" class="headerlink" title="输入样例"></a>输入样例</h4><p>3<br>1.00 2.00 -1.00 -6.00<br>2.00 1.00 -3.00 -9.00<br>-1.00 -1.00 2.00 7.00  </p><h4 id="输出样例-19"><a href="#输出样例-19" class="headerlink" title="输出样例"></a>输出样例</h4><p>1.00<br>-2.00<br>3.00</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">110</span>;<span class="hljs-keyword">double</span> m[M][M];<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> esp = <span class="hljs-number">1e-5</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">out</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt;=n;j++)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.2lf "</span>,m[i][j]);        <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">"\n"</span>;    &#125;    <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">"\n"</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;c &lt;n;c++)&#123;        <span class="hljs-keyword">int</span> t = r;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = r;i &lt; n;i++)            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(m[i][c]) &gt; <span class="hljs-built_in">fabs</span>(m[t][c])) t = i;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(m[t][c]) &lt; esp) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = c;i &lt;=n;i++) swap(m[t][i],m[r][i]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n;i &gt;=c;i--) m[r][i] /= m[r][c];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = r + <span class="hljs-number">1</span>;i &lt; n;i++)&#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(m[i][c]) &gt; esp)&#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = n;j &gt;=c;j--)                    m[i][j] -= m[r][j]*m[i][c];            &#125;        &#125;        r++;    &#125;    <span class="hljs-keyword">if</span>(r &lt; n)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = r;i &lt; n;i++)            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(m[i][n]) &gt; esp)                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>;j &lt; n;j++)            m[i][n] -= m[j][n]*m[i][j];    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">cin</span> &gt;&gt; n;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt;=n;j++)            <span class="hljs-built_in">cin</span> &gt;&gt; m[i][j];    <span class="hljs-keyword">int</span> t = solve();    <span class="hljs-keyword">if</span>(t == <span class="hljs-number">1</span>) <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">"Infinite group solutions"</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t == <span class="hljs-number">2</span>)<span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">"No solution"</span>;    <span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.2lf\n"</span>,m[i][n]);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/07/03/hello-world/"/>
    <url>/2020/07/03/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;functional&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;mutex&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> RET,<span class="hljs-keyword">typename</span>... ARGS&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Obserable</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">using</span> Functor = function&lt;<span class="hljs-keyword">void</span> (ARGS...)&gt;;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(Functor&amp;&amp; func)</span></span>&#123;        <span class="hljs-function">lock_guard&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;        functors_.push_back(forward&lt;Functor&gt;(func));    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(ARGS&amp;&amp;... args)</span></span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> Functor&amp; f :functors_)&#123;            f(args...);        &#125;    &#125;<span class="hljs-keyword">private</span>:    mutex mutex_;    <span class="hljs-built_in">vector</span>&lt;Functor&gt; functors_;&#125;;</code></pre><script type="math/tex; mode=display">\int_{-\infty}^{\infty}f(t)e^{-jwt}dt</script><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
