<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>os - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2021-02-19 21:55">
      February 19, 2021 pm
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.1k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      71
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="内存管理"><a class="markdownIt-Anchor" href="#内存管理"></a> 内存管理</h1>
<h2 id="分页虚拟内存"><a class="markdownIt-Anchor" href="#分页虚拟内存"></a> 分页虚拟内存</h2>
<h3 id="tlb刷新"><a class="markdownIt-Anchor" href="#tlb刷新"></a> TLB刷新</h3>
<ul>
<li>
<p>AARCH64内核和应用程序使用不同页表</p>
<ul>
<li>页表地址分别存放在TTBR0_EL1和TTBR1_EL1</li>
<li>系统调用无需切换页表</li>
</ul>
</li>
<li>
<p>x86_64唯一页表基址存放在CR3</p>
<ul>
<li>将内核映射到高地址</li>
<li>避免系统调用TLB刷新开销</li>
</ul>
</li>
</ul>
<h3 id="如何降低tlb刷新开销"><a class="markdownIt-Anchor" href="#如何降低tlb刷新开销"></a> 如何降低TLB刷新开销</h3>
<ul>
<li>
<p><strong>为不同的页表打上标签</strong></p>
<ul>
<li>TLB缓存项都有标签，切换页表不需要刷新TLB</li>
</ul>
</li>
<li>
<p><strong>x86_64:PCID</strong></p>
<ul>
<li>PCID存储在CR3的低12位</li>
</ul>
</li>
<li>
<p><strong>AARCH64:ASID</strong></p>
<ul>
<li>OS为不同进程分配8/16位ASID,将ASID存在TTBR0_EL1的高8/16位</li>
</ul>
</li>
</ul>
<h3 id="tlb与多核"><a class="markdownIt-Anchor" href="#tlb与多核"></a> TLB与多核</h3>
<ul>
<li>需要刷新其他核的TLB吗？
<ul>
<li>一个进程可能在多个核上运行</li>
</ul>
</li>
<li>如何知道需要刷新哪些核心?
<ul>
<li>通过系统的调度信息</li>
</ul>
</li>
<li>怎么刷新其他核?
<ul>
<li>x86_64 ：发送IPI中断某个核，通知他主动刷新</li>
<li>AARCH64 : 可在local CPU上刷新其他核TLB</li>
</ul>
</li>
</ul>
<h1 id="进程与线程"><a class="markdownIt-Anchor" href="#进程与线程"></a> 进程与线程</h1>
<h2 id="纤程"><a class="markdownIt-Anchor" href="#纤程"></a> 纤程</h2>
<h3 id="linux纤程支持-ucontext"><a class="markdownIt-Anchor" href="#linux纤程支持-ucontext"></a> Linux纤程支持 : ucontext</h3>
<ul>
<li><code>makecontext</code> 创建新ucontext</li>
<li><code>setcontext</code>  纤程切换</li>
<li><code>getcontext</code> 保存当前ucontext</li>
</ul>
<h1 id="ipc"><a class="markdownIt-Anchor" href="#ipc"></a> IPC</h1>
<h2 id="共享内存"><a class="markdownIt-Anchor" href="#共享内存"></a> 共享内存</h2>
<ul>
<li>操作系统为两个进程映射共同的内存区域</li>
<li>需要轮询是否有数据到达，导致资源浪费</li>
</ul>
<h2 id="消息传递"><a class="markdownIt-Anchor" href="#消息传递"></a> 消息传递</h2>
<ul>
<li>通过内核消息传递机制发送和接收消息</li>
<li><code>Send(message)</code> <code>Recv(message)</code> 会阻塞进程，不会浪费资源</li>
<li><code>Send</code> 可以非阻塞，增大通信带宽，引入超时机制防止资源浪费</li>
</ul>
<h1 id="同步"><a class="markdownIt-Anchor" href="#同步"></a> 同步</h1>
<h2 id="解决临界区问题的三个要求"><a class="markdownIt-Anchor" href="#解决临界区问题的三个要求"></a> 解决临界区问题的三个要求</h2>
<ul>
<li><strong>互斥访问</strong>：同一时刻仅有一个进程可以进入临界区</li>
<li><strong>有限等待</strong>：当一个进程在申请进入临界区后，必须在有限的时间获得许可进入临界区，不能无限等待</li>
<li><strong>空闲让进</strong>：当没有进程在临界区中时，必须在请求进入临界区的进程中选择一个进入临界区，保证程序正常推进</li>
</ul>
<h2 id="互斥访问实现"><a class="markdownIt-Anchor" href="#互斥访问实现"></a> 互斥访问实现</h2>
<ul>
<li><strong>关中断</strong>：保证执行过程不被打断. <em>仅适用于单核</em></li>
</ul>
<h3 id="compare-and-swapcas"><a class="markdownIt-Anchor" href="#compare-and-swapcas"></a> Compare And Swap(CAS)</h3>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CAS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* addr,<span class="hljs-keyword">int</span> expected,<span class="hljs-keyword">int</span> new_value)</span></span>&#123;
    <span class="hljs-keyword">int</span> tmp = *addr;
    <span class="hljs-keyword">if</span>(*addr == expected)
        *addr = new_value;
    <span class="hljs-keyword">return</span> tmp;
&#125;</code></pre>
<p>CAS为硬件原子操作：</p>
<ul>
<li>Intel锁总线实现</li>
<li>ARM：采用Load Link, Store Condition<pre><code class="hljs asm">retry: 
  ldxr x0,addr #ll
  cmp x0,expected
  bne out
  stxr x1,new_value,addr #sc
  cbnx x1,retry
out:</code></pre>
修改时看addr是否被修改过，若修改过则重试</li>
</ul>
<h3 id="锁实现"><a class="markdownIt-Anchor" href="#锁实现"></a> 锁实现</h3>
<h4 id="自旋锁spinlock"><a class="markdownIt-Anchor" href="#自旋锁spinlock"></a> 自旋锁(Spinlock)</h4>
<p>lock操作</p>
<pre><code class="hljs c"><span class="hljs-keyword">while</span>(atomic_CAS(lock,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) != <span class="hljs-number">0</span>);</code></pre>
<p>unlock</p>
<pre><code class="hljs c">*lock = <span class="hljs-number">0</span>;</code></pre>
<ul>
<li>可能出现饥饿现象</li>
</ul>
<h4 id="排号锁ticket-lock"><a class="markdownIt-Anchor" href="#排号锁ticket-lock"></a> 排号锁(Ticket Lock)</h4>
<ul>
<li>保证竞争者的公平性</li>
<li>根据竞争者到达的先后顺序传递锁</li>
</ul>
<p><strong>lock操作</strong></p>
<pre><code class="hljs c"><span class="hljs-comment">// 拿号</span>
my_ticket = atomic_FAA(&amp;lock-&gt;next,<span class="hljs-number">1</span>); <span class="hljs-comment">// fetch and add </span>

<span class="hljs-comment">// 等号</span>
<span class="hljs-keyword">while</span>(lock-&gt;owner != my_ticket);</code></pre>
<p><strong>unlock操作</strong></p>
<pre><code class="hljs c">lock-&gt;owner++;</code></pre>
<h4 id="读写锁"><a class="markdownIt-Anchor" href="#读写锁"></a> 读写锁</h4>
<ul>
<li>多个读者不互斥</li>
<li>读者与写者互斥</li>
</ul>
<h5 id="读者优先"><a class="markdownIt-Anchor" href="#读者优先"></a> 读者优先</h5>
<pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rw_lock</span>&#123;</span>
    <span class="hljs-keyword">int</span> reader;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span> <span class="hljs-title">reader_lock</span>;</span> <span class="hljs-comment">// 锁住reader变量</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span> <span class="hljs-title">writer_lock</span>;</span>
&#125;;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock_reader</span><span class="hljs-params">(struct rw_lock* lock)</span></span>&#123;
    lock(&amp;lock-&gt;reader_lock);
    lock-&gt;reader++;
    <span class="hljs-keyword">if</span>(lock-&gt;reader == <span class="hljs-number">1</span>)
        lock(&amp;lock-&gt;writer_lock);
    unlock(&amp;lock-&gt;reader_lock);
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock_reader</span><span class="hljs-params">(struct rw_lock* lock)</span></span>&#123;
    lock(&amp;lock-&gt;reader_lock);
    lock-&gt;reader--;
    <span class="hljs-keyword">if</span>(lock-&gt;reader == <span class="hljs-number">0</span>)
        unlock(&amp;lock-&gt;writer_lock);
    unlock(&amp;lock-&gt;reader_lock);
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock_writer</span><span class="hljs-params">(struct rw_lock* lock)</span></span>&#123;
    lock(&amp;lock-&gt;writer_lock);
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock_writer</span><span class="hljs-params">(struct rw_lock* lock)</span></span>&#123;
    unlock(&amp;lock-&gt;writer_lock);
&#125;</code></pre>
<ul>
<li>需要一个reader_lock保护reader变量，如何提高读者性能</li>
</ul>
<p><strong>Read Copy Update(RCU)</strong></p>
<ul>
<li>减少读者进入临界区的操作，提高读者效率</li>
</ul>
<p>硬件原子操作</p>
<ol>
<li>最大128bit</li>
<li>锁总线，性能瓶颈</li>
</ol>
<p>链表删除节点<br />
<img src="/image/os/link%20list%20delete.png" srcset="/img/loading.gif" alt="" /></p>
<p><strong>局限</strong></p>
<ul>
<li>需要将源数据复制一份，导致内存消耗</li>
<li>删除后的节点不能立即删除，因为可能有读者正在读</li>
</ul>
<p><strong>RCU宽限期</strong></p>
<ul>
<li>需要知道进入临界区和离开临界区的时间</li>
<li>当最后一个访问旧值的读者离开临界区后释放内存</li>
</ul>
<h3 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h3>
<p><strong>原因</strong></p>
<ul>
<li>互斥访问</li>
<li>持有并等待</li>
<li>资源非抢占</li>
<li>循环等待</li>
</ul>
<h4 id="检测死锁与回复"><a class="markdownIt-Anchor" href="#检测死锁与回复"></a> 检测死锁与回复</h4>
<p>找到资源分配图中的环</p>
<ul>
<li>kill所有进程</li>
<li>kill一个进程</li>
<li>全部回滚到前面状态</li>
</ul>
<h4 id="死锁预防"><a class="markdownIt-Anchor" href="#死锁预防"></a> 死锁预防</h4>
<ol>
<li>
<p>避免互斥访问：通过其他手段（ie:代理执行）</p>
</li>
<li>
<p>不允许持有并等待：一次申请所有资源</p>
<ul>
<li>可能带来活锁(live lock)</li>
<li><img src="../image/os/live_lock.png" srcset="/img/loading.gif" alt="" /></li>
</ul>
</li>
<li>
<p>资源允许抢占：需要考虑如何恢复（取决于场景）</p>
</li>
<li>
<p>打破循环等待</p>
</li>
</ol>
<h4 id="死锁避免"><a class="markdownIt-Anchor" href="#死锁避免"></a> 死锁避免</h4>
<p>银行家算法</p>
<h2 id="多核与并行"><a class="markdownIt-Anchor" href="#多核与并行"></a> 多核与并行</h2>
<p><strong>并行加速比（理论上限）</strong><br />
Amdahl’s Law</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>=</mo><mfrac><mn>1</mn><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="false">)</mo><mo>+</mo><mi>p</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">s = \frac{1}{(1-p)+p/s}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.25744em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">p</span><span class="mord">/</span><span class="mord mathdefault">s</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>:</mo></mrow><annotation encoding="application/x-tex">p:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span></span></span>可并行部分所占比例<br />
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>:</mo></mrow><annotation encoding="application/x-tex">s:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span></span></span>并行核心数</p>
</blockquote>
<p>多核访问共享数据导致性能断崖</p>
<h3 id="缓存一致性"><a class="markdownIt-Anchor" href="#缓存一致性"></a> 缓存一致性</h3>
<h4 id="msi状态"><a class="markdownIt-Anchor" href="#msi状态"></a> MSI状态</h4>
<p><img src="/image/os/modified.png" srcset="/img/loading.gif" alt="" /><br />
<img src="/image/os/shared.png" srcset="/img/loading.gif" alt="" /><br />
<img src="/image/os/invalid.png" srcset="/img/loading.gif" alt="" /></p>
<p><img src="/image/os/cache.png" srcset="/img/loading.gif" alt="" /></p>
<p>多cpu对单一缓存行竞争导致性能下降</p>
<p><strong>MCS lock</strong></p>
<ul>
<li>避免多核对于单一缓存行的竞争<br />
<img src="/image/os/mcs.png" srcset="/img/loading.gif" alt="" /></li>
</ul>
<pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_node</span>&#123;</span>
    <span class="hljs-keyword">volatile</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_node</span>* <span class="hljs-title">next</span>;</span>
    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> flag;
&#125;;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_lock</span>&#123;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_node</span>* <span class="hljs-title">tail</span>;</span>
&#125;;
__thread <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_node</span> <span class="hljs-title">my_node</span>;</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">(struct mcs_lock* lock)</span></span>&#123;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_node</span>* <span class="hljs-title">me</span> = &amp;<span class="hljs-title">my_node</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_node</span>* <span class="hljs-title">tail</span> = 0;</span>
    me-&gt;next = <span class="hljs-literal">NULL</span>;
    me-&gt;flag = WATTING;
    tail = atomic_XCHG(&amp;lock-&gt;tail,me);

    <span class="hljs-keyword">if</span>(tail)&#123;
        barrier();
        tail-&gt;next = me;
        <span class="hljs-keyword">while</span>(me-&gt;flag != GRANTED);

    &#125;<span class="hljs-keyword">else</span>&#123;
        me-&gt;flag = GRANTED;
    &#125;
    barrier();
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">(struct mcs_lock* lock)</span></span>&#123;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_node</span>* <span class="hljs-title">me</span> = &amp;<span class="hljs-title">my_node</span>;</span>
    barrier();
    <span class="hljs-keyword">if</span>(!me-&gt;next)&#123;
        <span class="hljs-keyword">if</span>(atomic_CAS(&amp;lock-&gt;tail,me,<span class="hljs-number">0</span>) == me)
            <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">while</span>(!me-&gt;next);
    &#125;
    me-&gt;next-&gt;flag = GRANTED;
&#125;</code></pre>
<ul>
<li>unlock操作仅写一个私缓存行，不存在高度竞争的全局缓存行</li>
</ul>
<p>在非一致内存访问(NUMA)下，在临界区访问多cache行导致性能下降</p>
<p><img src="/image/os/numa.png" srcset="/img/loading.gif" alt="" /></p>
<ul>
<li>跨节点的缓存一致性协议开销巨大(cpu需要访问其他节点的cache取回数据)</li>
</ul>
<p><strong>NUMA-aware设计：cohort</strong></p>
<ul>
<li>先获取每节点的本地锁，在获取全局锁</li>
<li>成功获取全局锁，释放时将其传递给<strong>本地等待队列</strong>的下一位</li>
<li>全局锁在一段时间内只在一个节点内部传递</li>
</ul>
<h3 id="内存模型"><a class="markdownIt-Anchor" href="#内存模型"></a> 内存模型</h3>
<h4 id="严格一致性模型strict-consistency"><a class="markdownIt-Anchor" href="#严格一致性模型strict-consistency"></a> 严格一致性模型(Strict Consistency)</h4>
<ul>
<li>对任意地址的读操作都能读到这个地址最近一次写的数据</li>
<li>访存操作顺序与全局时钟顺序一致</li>
<li>有唯一的执行结果</li>
</ul>
<h4 id="顺序一致性sequential-consistency"><a class="markdownIt-Anchor" href="#顺序一致性sequential-consistency"></a> 顺序一致性(Sequential Consistency)</h4>
<ul>
<li>不要求操作按照真实的时间顺序全局可见</li>
<li>执行结果必须与一个全局的顺序一致</li>
<li>在调度下具有多种结果</li>
</ul>
<h4 id="tsototal-store-ordering"><a class="markdownIt-Anchor" href="#tsototal-store-ordering"></a> TSO(Total Store Ordering)</h4>
<ul>
<li>
<p>对不同地址<strong>RR</strong>,<strong>RW</strong>,<strong>WW</strong>顺序可以保证</p>
</li>
<li>
<p><strong>WR</strong>的顺序不能保证</p>
</li>
<li>
<p>CPU存在乱序执行<br />
CPU写cache后需要执行缓存一致性算法，为了提升性能，在CPU与cache之间增加一个<strong>Load/Store Buffer</strong>,CPU写数据首先写入<strong>Buffer</strong>,之后将数据批量写入cache，减少缓存一致性算法执行次数。但是导致了写延时，所以导致<strong>WR</strong>的顺序不能保证</p>
</li>
</ul>
<h4 id="弱一致性模型"><a class="markdownIt-Anchor" href="#弱一致性模型"></a> 弱一致性模型</h4>
<ul>
<li>不保证任何对不同地址的读写操作顺序<br />
ARM采用弱一致性模型，为了保证读写顺序，ARM提供了<code>barrier()</code>保证执行顺序。在<code>lock</code>时需要加<code>barrier</code></li>
</ul>
<h1 id="文件与存储"><a class="markdownIt-Anchor" href="#文件与存储"></a> 文件与存储</h1>
<h2 id="基于inode的文件系统"><a class="markdownIt-Anchor" href="#基于inode的文件系统"></a> 基于inode的文件系统</h2>
<ul>
<li>字符/块设备文件
<ul>
<li>记录设备的Major(表示设备类型)和minor(表示设备编号)号</li>
<li>可以作为系统调用参数</li>
</ul>
</li>
<li>FIFO文件
<ul>
<li>命名管道，用于进程通信</li>
<li>提供一个标识符，对该文件操作都在内存中，实现了<code>read()</code>,<code>write()</code>等接口</li>
</ul>
</li>
<li>SOCK文件
<ul>
<li>UNIX域套接字，用于进程间通信</li>
<li>通过<strong>socket</strong>API创建，当进程位于不同机器上时，仅需要修改少部分代码</li>
</ul>
</li>
</ul>
<p>这些方式复用了文件API，通过文件API实现不同的功能.</p>
<blockquote>
<p>everything is a file.</p>
</blockquote>
<h2 id="基于table的文件系统"><a class="markdownIt-Anchor" href="#基于table的文件系统"></a> 基于Table的文件系统</h2>
<h3 id="ntfs"><a class="markdownIt-Anchor" href="#ntfs"></a> NTFS</h3>
<p><img src="/image/os/ntfs.png" srcset="/img/loading.gif" alt="" /></p>
<ul>
<li>每个文件在MFT中保留一项，记录了文件的元数据</li>
<li>查询文件仅需变量MFT，查询速度快  eg:everything</li>
<li>文件较小时可以内嵌在MFT中</li>
</ul>
<p><img src="/image/os/filesystem.png" srcset="/img/loading.gif" alt="" /></p>
<p><img src="/image/os/clone.png" srcset="/img/loading.gif" alt="" /></p>
<ul>
<li>使用COW实现快照功能
<ul>
<li>将inode复制一份作为快照</li>
<li>标记数据块为COW</li>
</ul>
</li>
</ul>
<h3 id="fuse"><a class="markdownIt-Anchor" href="#fuse"></a> FUSE</h3>
<p><img src="/image/os/fuse.png" srcset="/img/loading.gif" alt="" /></p>
<ul>
<li>在用户态实现文件系统，eg：将百度网盘映射到文件系统</li>
</ul>
<h2 id="崩溃一致性"><a class="markdownIt-Anchor" href="#崩溃一致性"></a> 崩溃一致性</h2>
<h3 id="各种数据结构之间存在依赖关系与一致性要求"><a class="markdownIt-Anchor" href="#各种数据结构之间存在依赖关系与一致性要求"></a> 各种数据结构之间存在依赖关系与一致性要求</h3>
<ul>
<li>inode中保存的文件大小，应该与其索引中保存的数据块个数相匹配- inode中保存的链接数，应与指向其的目录项个数相同</li>
<li>超级块中保存的文件系统大小，应该与文件系统所管理的空间大小相同</li>
<li>所有inode分配表中标记为空闲的inode均未被使用;标记为已用的inode均可以通过文件系统操作访问</li>
</ul>
<p><strong>系统崩溃情况下这些数据可能不一致</strong></p>
<h3 id="日志"><a class="markdownIt-Anchor" href="#日志"></a> 日志</h3>
<ul>
<li>在文件操作之前，先将操作记录在日志中</li>
<li>所有操作记录完毕后，提交日志</li>
<li>再对文件进行操作</li>
</ul>
<p><strong>问题</strong></p>
<ul>
<li>每个操作都要写硬盘，内存缓存机制无意义</li>
<li>每个修改需要拷贝新数据到日志</li>
<li>相同块的修改被记录多次</li>
</ul>
<p><strong>解决方案</strong></p>
<ul>
<li>利用内存的页缓存：将日志保存在内存中，文件操作之前将日志写入磁盘</li>
<li>批量处理日志减少磁盘读写：将多个文件操作合并，每个修改的块仅需记录一次</li>
</ul>
<p><strong>日志提交</strong></p>
<ul>
<li>
<p>定时触发</p>
<ul>
<li>每一段时间触发一次</li>
<li>日志达到一定数量触发一次</li>
</ul>
</li>
<li>
<p>用户触发</p>
<ul>
<li>应用程序调用<code>fsync()</code></li>
</ul>
</li>
</ul>
<h1 id="系统虚拟化"><a class="markdownIt-Anchor" href="#系统虚拟化"></a> 系统虚拟化</h1>
<ul>
<li>
<p>操作系统的接口层次</p>
<ul>
<li>ISA层
<ul>
<li>用户ISA：用户态可执行 eg:<code>mov, add</code></li>
<li>系统ISA：特权态可执行 eg:<code>msr</code></li>
</ul>
</li>
<li>ABI
<ul>
<li>提供操作系统服务或硬件功能</li>
<li>包含用户ISA和syscall</li>
</ul>
</li>
<li>API
<ul>
<li>不同用户态库提供的接口</li>
<li>包含库接口和用户ISA eg:<code>libc</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>虚拟机监控器(VMM/Hypervisor)</p>
<ul>
<li>向上层虚拟机暴漏其所需的ISA</li>
<li>可同时运行多台虚拟机(VM)</li>
<li>需要VMM实现系统ISA的功能：eg：切换内核页表寄存器(TTBR1)</li>
</ul>
</li>
</ul>
<h2 id="如何实现vmm"><a class="markdownIt-Anchor" href="#如何实现vmm"></a> 如何实现VMM</h2>
<ul>
<li>实现系统ISA<br />
系统ISA设计时仅考虑只有一个人调，不允许多个人执行，要实现让多个人调用系统ISA，当运行系统ISA时，不能由硬件真正运行系统ISA</li>
</ul>
<p><img src="/image/os/trap.png" srcset="/img/loading.gif" alt="" /></p>
<ol>
<li>捕捉所有系统ISA并陷入(Trap)</li>
<li>由具体指令实现相应虚拟化
<ul>
<li>控制虚拟处理器行为</li>
<li>控制虚拟内存行为</li>
<li>控制设备行为</li>
</ul>
</li>
<li>回到虚拟机继续执行</li>
</ol>
<h2 id="cpu虚拟化"><a class="markdownIt-Anchor" href="#cpu虚拟化"></a> CPU虚拟化</h2>
<p><img src="/image/os/vis1.png" srcset="/img/loading.gif" alt="" /></p>
<ul>
<li>将VMM运行在EL1</li>
<li>将guest操作系统和其进程运行在EL0</li>
<li>当操作系统执行ISA指令时Trap进入EL1的VMM由VMM模拟实现</li>
<li><img src="/image/os/vis11.png" srcset="/img/loading.gif" alt="" /></li>
</ul>
<p>x86和arm有些指令不能虚拟化(在EL0和EL1下执行效果不一样),在用户态执行被当作<code>NOP</code>指令，不会产生Trap</p>
<h3 id="如何处理不会产生trap的系统指令"><a class="markdownIt-Anchor" href="#如何处理不会产生trap的系统指令"></a> 如何处理不会产生Trap的系统指令</h3>
<ol>
<li>解释执行</li>
<li>二级制翻译</li>
<li>半虚拟化</li>
<li>硬件虚拟化(修改硬件)</li>
</ol>
<h4 id="1解释执行"><a class="markdownIt-Anchor" href="#1解释执行"></a> 1.解释执行</h4>
<ul>
<li>用软件对所有的虚拟机代码模拟执行
<ul>
<li>不区分是否敏感指令</li>
<li>没有虚拟机指令直接在硬件上执行</li>
</ul>
</li>
<li>在内存中维护虚拟机的状态<br />
<img src="/image/os/trap1.png" srcset="/img/loading.gif" alt="" /></li>
</ul>
<p>pros</p>
<ul>
<li>解决了敏感函数不Trap问题</li>
<li>可以模拟不同ISA的虚拟机</li>
<li>实现简单</li>
</ul>
<p>cons</p>
<ul>
<li>执行速度慢，一条指令会被模拟为多条指令</li>
</ul>
<h4 id="2二级制翻译"><a class="markdownIt-Anchor" href="#2二级制翻译"></a> 2.二级制翻译</h4>
<ul>
<li>提出两个加速技术
<ul>
<li>执行前<strong>批量翻译</strong>虚拟机指令</li>
<li><strong>缓存</strong>已经翻译的指令</li>
</ul>
</li>
<li>使用基本块(Basic Block)为翻译粒度<br />
<img src="/image/os/trap2.png" srcset="/img/loading.gif" alt="" /></li>
</ul>
<p>cons:</p>
<ul>
<li>不能处理自修改的代码(eg:jvm)</li>
<li>中断插入粒度变大
<ul>
<li>模拟执行可在任意指令位置插入中毒</li>
<li>二进制翻译只能在Basic Block边界插入中断(执行Basic Block时VMM没有介入)</li>
</ul>
</li>
</ul>
<h4 id="3半虚拟化"><a class="markdownIt-Anchor" href="#3半虚拟化"></a> 3.半虚拟化</h4>
<ul>
<li>让VMM提供接口给虚拟机，称为<strong>Hypercall</strong></li>
<li>修改guest操作系统源码，将敏感指令替换为<strong>Hypercall</strong></li>
</ul>
<p>cons</p>
<ul>
<li>需要修改操作系统源码</li>
</ul>
<h4 id="4硬件虚拟化"><a class="markdownIt-Anchor" href="#4硬件虚拟化"></a> 4.硬件虚拟化</h4>
<ul>
<li>
<p>x86和arm引入了虚拟化特权级</p>
</li>
<li>
<p>x86引入了<strong>root mode</strong>和<strong>non-root mode</strong></p>
<ul>
<li>intel 推出了VT-x硬件虚拟化扩展</li>
<li><strong>root mode</strong>是最高特权级，控制物理资源</li>
<li>VMM运行在<strong>root mode</strong>,虚拟机运行在<strong>non-root mode</strong></li>
<li>两个mode内都有4个特权级：ring0-ring3</li>
</ul>
</li>
<li>
<p>arm引入了EL2</p>
<ul>
<li>VMM运行在EL2</li>
<li>EL2是最高特权级，控制物理资源</li>
<li>VMM的操作系统和应用程序分别运行在EL1和EL0</li>
</ul>
</li>
</ul>
<h4 id="vt-x"><a class="markdownIt-Anchor" href="#vt-x"></a> VT-x</h4>
<p><img src="/image/os/trap41.png" srcset="/img/loading.gif" alt="" /></p>
<h5 id="virtual-machine-control-structurevmcs"><a class="markdownIt-Anchor" href="#virtual-machine-control-structurevmcs"></a> Virtual Machine Control Structure(VMCS)</h5>
<ul>
<li>
<p>VMM提供给硬件的内存页(4KB)</p>
<ul>
<li>记录当前VM的运行状态</li>
</ul>
</li>
<li>
<p>VM Entry</p>
<ul>
<li>硬件自动将当前CPU中的VMM状态保存到VMCS</li>
<li>硬件自动从VMCS中加载VM状态到CPU</li>
</ul>
</li>
<li>
<p>VM　Exit</p>
<ul>
<li>硬件自动将当前CPU中的VM状态保存到VMCS</li>
<li>硬件自动从VMCS中加载VMM状态到CPU</li>
</ul>
</li>
<li>
<p>包含6个部分</p>
<ul>
<li>Guest-state area:发生VM exit时，CPU的状态会被硬件自动保存至该区域;发生VM Entry时，硬件自动从该区域加载状态至CPU中</li>
<li>Host-state area:发生VM exit时，硬件自动从该区域加载状态至CPU中;发生VM Entry时，CPU的状态会被自动保存至该区域</li>
<li>VM-execution control fields :控制Non-root模式中虚拟机的行为</li>
<li>VM-exit control fields :控制VM exit的行为</li>
<li>VM-entry control fields :控制VM entry的行为</li>
<li>VM-exit information fields : VM Exit的原因和相关信息（只读区域)</li>
</ul>
</li>
</ul>
<ol>
<li>VMXON 开启VT-x</li>
<li>VMLAUNCH 进入虚拟机(加载虚拟机的状态)</li>
<li>当遇到满足VMEXIT指令 -&gt; VMM ring0, VMM执行该指令</li>
<li>VMRESUME 回到虚拟机</li>
</ol>
<p><strong>x86修改CPU为了给VM一个新环境，arm修改虚拟机为了给VMM一个新环境</strong></p>
<h4 id="arm虚拟化"><a class="markdownIt-Anchor" href="#arm虚拟化"></a> ARM虚拟化</h4>
<p><img src="/image/os/armvirtual.png" srcset="/img/loading.gif" alt="" /></p>
<ul>
<li>
<p>VM Entry</p>
<ul>
<li>使用ERET指令从VMM进入VM</li>
<li>进入VM之前VMM需要主动加载VM的运行状态(各种寄存器)</li>
</ul>
</li>
<li>
<p>VM Exit</p>
<ul>
<li>虚拟机执行敏感指令或收到中断</li>
<li>以Exception、IRQ、FIQ形式回到VMM</li>
<li>VMM主动保存VM的状态</li>
</ul>
</li>
<li>
<p>VM Exit时VMM可以访问VM的EL0和EL1寄存器</p>
</li>
</ul>
<h3 id="vm和vcpu"><a class="markdownIt-Anchor" href="#vm和vcpu"></a> VM和VCPU</h3>
<ul>
<li>
<p>VM</p>
<ul>
<li>静态部分：内存，设备等</li>
<li>动态部分：VCPU</li>
</ul>
</li>
<li>
<p>VCPU</p>
<ul>
<li>用线程模拟CPU</li>
<li>虚拟寄存器
<ul>
<li>PC</li>
<li>通用寄存器</li>
<li>…</li>
</ul>
</li>
<li>切换VCPU时切换到其虚拟寄存器</li>
</ul>
</li>
</ul>
<h3 id="qemukvm"><a class="markdownIt-Anchor" href="#qemukvm"></a> QEMU/KVM</h3>
<ul>
<li>
<p>qemu运行在用户态，实现策略</p>
<ul>
<li>也提供虚拟设备支持</li>
</ul>
</li>
<li>
<p>KVM以linux内核模块运行，实现机制</p>
<ul>
<li>可以直接使用linux的功能(内存管理，进程调度)</li>
<li>使用硬件虚拟化功能</li>
</ul>
</li>
<li>
<p>KVM捕捉所有敏感指令和事件，传递给QEMU</p>
</li>
<li>
<p>KVM不提供设备虚拟化，需要使用QEMU的虚拟设备</p>
</li>
<li>
<p>1个虚拟机对应1个QEMU进程</p>
</li>
<li>
<p>VM的VCPU对应QEMU的线程</p>
</li>
<li>
<p>QEMU使用<code>/dev/kvm</code>与内核态的KVM通信</p>
<ul>
<li>使用ioctl向KVM传递命令：<code>CREATE_VM</code>,<code>CREATE_VCPU</code>,<code>KVM_RUN</code>…</li>
<li>创建虚拟机所需的运行环境(memory,VCPU,…)后调用<code>KVM_RUN</code>进入<strong>non-root mode</strong>执行<br />
<img src="/image/os/kvm.png" srcset="/img/loading.gif" alt="" /></li>
</ul>
</li>
</ul>
<pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ioctl.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/kvm.h&gt;</span></span>

  <span class="hljs-keyword">int</span> fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">"/dev/kvm"</span>);
  ioctl(fd,KVM_CREATE_VM);
  ioctl(fd,KVM_CREATE_VCPU);
  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;
    ioctl(fd,KVM_RUN); <span class="hljs-comment">// 进入内核 -&gt; 返回到VM</span>
    <span class="hljs-comment">// VM执行到敏感指令 -&gt; trap kernel -&gt; KVM [-&gt; qemu]</span>
    reason = get_exit_reason();
    <span class="hljs-keyword">switch</span>(reason)&#123;
      <span class="hljs-keyword">case</span> ...

    &#125;
  &#125;</code></pre>
<h4 id="ioctlfdkvm_run"><a class="markdownIt-Anchor" href="#ioctlfdkvm_run"></a> ioctl(fd,KVM_RUN)</h4>
<ul>
<li>
<p>ARM</p>
<ul>
<li>KVM主动加载VCPU的所有状态</li>
<li>使用<code>eret</code>进入VM</li>
</ul>
</li>
<li>
<p>x86</p>
<ul>
<li>KVM找到VCPU对应的VMCS</li>
<li>使用指令加载VMCS</li>
<li><code>VMLAUNCH</code>/<code>VMRESUME</code>进入<strong>non-root node</strong>
<ul>
<li>硬件自动同步状态</li>
<li>PC = VMCS-&gt;GUEST_RIP</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="io处理流程"><a class="markdownIt-Anchor" href="#io处理流程"></a> IO处理流程</h4>
<p><img src="/image/os/kvmio.png" srcset="/img/loading.gif" alt="" /></p>
<h2 id="内存虚拟化"><a class="markdownIt-Anchor" href="#内存虚拟化"></a> 内存虚拟化</h2>
<ul>
<li>
<p>为虚拟机提供虚拟的物理地址空间</p>
</li>
<li>
<p>三种地址</p>
<ul>
<li>Guest Virtual Address(GVA)
<ul>
<li>虚拟机内进程使用的虚拟地址</li>
</ul>
</li>
<li>Guest Physical Address(GPA)
<ul>
<li>虚拟机内使用的假物理地址</li>
</ul>
</li>
<li>Host Physical Address(HPA)
<ul>
<li>真实的物理地址</li>
<li>GPA需要翻译为HPA</li>
</ul>
</li>
</ul>
</li>
<li>
<p>实现内存虚拟化</p>
<ul>
<li>影子页表(Shadow Page Table):为每个进程提供一个<code>GVA-&gt;HPA</code>的页表</li>
<li>直接页表(Direct Page Table):告诉VM运行在虚拟机中</li>
<li>硬件虚拟化</li>
</ul>
</li>
</ul>
<h3 id="硬件虚拟化"><a class="markdownIt-Anchor" href="#硬件虚拟化"></a> 硬件虚拟化</h3>
<ul>
<li>Intel Extended Page Table(EPT)</li>
<li>ARM Stage-2 Page Table(第二阶段页表)</li>
<li>新页表
<ul>
<li>将GPA翻译为HPA</li>
<li>被VMM控制</li>
<li>每个VM有一个对应页表</li>
</ul>
</li>
</ul>
<h4 id="翻译过程"><a class="markdownIt-Anchor" href="#翻译过程"></a> 翻译过程</h4>
<p><img src="/image/os/step2.png" srcset="/img/loading.gif" alt="" /></p>
<ul>
<li>Guest Page Table 中保存 GPA</li>
<li>Host Page Table 中保存 HPA</li>
<li>共24次访存</li>
</ul>
<h4 id="tlb刷新-2"><a class="markdownIt-Anchor" href="#tlb刷新-2"></a> TLB刷新</h4>
<ul>
<li>刷TLB相关指令
<ul>
<li>清空全部 <code>TLBI VMALLS12E1IS</code></li>
<li>清空指定GVA <code>TLBI VAE1IS</code></li>
<li>情况指定GPA <code>TLBI IPAS2E1IS</code></li>
</ul>
</li>
</ul>
<h4 id="如何处理缺页异常"><a class="markdownIt-Anchor" href="#如何处理缺页异常"></a> 如何处理缺页异常</h4>
<ul>
<li>第一阶段缺页异常
<ul>
<li>调用VM的Page fault handler</li>
<li>不会引起VM <strong>Trap</strong></li>
</ul>
</li>
<li>第二阶段缺页异常
<ul>
<li>VM Trap，直接调用VMM的Page fault handler</li>
</ul>
</li>
</ul>
<p>pros：</p>
<ul>
<li>不需要捕捉Guest Page Table的更新</li>
<li>减少内存开销：每个VM对应一个页表</li>
</ul>
<p>cons：</p>
<ul>
<li>TLB miss时性能开销大</li>
</ul>
<h2 id="io虚拟化"><a class="markdownIt-Anchor" href="#io虚拟化"></a> IO虚拟化</h2>
<ul>
<li>为VM提供虚拟设备</li>
<li>隔离不同VM对设备的访问</li>
<li>提高物理设备的利用率</li>
</ul>
<h3 id="如何实现io虚拟化"><a class="markdownIt-Anchor" href="#如何实现io虚拟化"></a> 如何实现IO虚拟化</h3>
<ul>
<li>设备模拟</li>
<li>半虚拟化</li>
<li>设备直通</li>
</ul>
<h4 id="设备模拟"><a class="markdownIt-Anchor" href="#设备模拟"></a> 设备模拟</h4>
<ul>
<li>
<p>OS与设备交互的接口</p>
<ul>
<li>模拟寄存器(中断)</li>
<li>捕捉MMIO,PIO指令</li>
</ul>
</li>
<li>
<p>软件模拟方式</p>
<ul>
<li>将PIO指令替换为系统调用</li>
<li>MMIO对应内存的第二阶段页表设为invalid(Trap)</li>
</ul>
</li>
<li>
<p>硬件虚拟化方式</p>
<ul>
<li>硬件捕捉PIO指令</li>
<li>MMIO对应内存的第二阶段页表设为invalid</li>
</ul>
</li>
</ul>
<p><img src="/image/os/netemu1.png" srcset="/img/loading.gif" alt="" /><br />
<img src="/image/os/netemu2.png" srcset="/img/loading.gif" alt="" /></p>
<h4 id="半虚拟化"><a class="markdownIt-Anchor" href="#半虚拟化"></a> 半虚拟化</h4>
<ul>
<li>VM知道自己运行在虚拟环境</li>
<li>VM运行<strong>front-end</strong></li>
<li>VMM运行<strong>back-end</strong></li>
<li>VMM给VM提供<strong>Hypercall</strong></li>
<li>通过共享内存传递指令和数据</li>
</ul>
<p><img src="/image/os/netemu3.png" srcset="/img/loading.gif" alt="" /></p>
<ul>
<li><strong>back-end</strong>可以在内核中实现</li>
</ul>
<p><img src="/image/os/netemu4.png" srcset="/img/loading.gif" alt="" /></p>
<p>pros:</p>
<ul>
<li>多个MMIO/PIO指令可以整合为一次Hypercall</li>
</ul>
<p>cons:</p>
<ul>
<li>需要修改操作系统内核</li>
</ul>
<h4 id="设备直通"><a class="markdownIt-Anchor" href="#设备直通"></a> 设备直通</h4>
<ul>
<li>由于网卡直接访问<strong>HPA</strong>,可能造成恶意读写</li>
<li>让网卡访问<strong>GPA</strong>,VM只能访问自己的内存</li>
</ul>
<p><strong>增加IOMMU</strong></p>
<p><img src="/image/os/iommu.png" srcset="/img/loading.gif" alt="" /></p>
<p><img src="/image/os/iommu2.png" srcset="/img/loading.gif" alt="" /></p>
<p><strong>设备独占问题</strong></p>
<ul>
<li>single root i/o virtualization
<ul>
<li>
<p>在物理层实现设备虚拟化</p>
</li>
<li>
<p>能够创建多个Virtual Function(VF),每个VM分配一个VF</p>
</li>
<li>
<p>物理设备称为Physical Function(PF),由Host管理</p>
</li>
<li>
<p>需要特定硬件(IOMMU等)支持</p>
</li>
</ul>
</li>
</ul>
<h2 id="中断虚拟化"><a class="markdownIt-Anchor" href="#中断虚拟化"></a> 中断虚拟化</h2>
<ul>
<li>VMM完成IO操作(DMA)后通知VM</li>
<li>VMM在<code>VM ENTRY</code>时插入中断</li>
</ul>
<h3 id="virtual-cpu-interface"><a class="markdownIt-Anchor" href="#virtual-cpu-interface"></a> virtual CPU interface</h3>
<ul>
<li>
<p>GIC为VM提供硬件功能</p>
<ul>
<li>VM通过virtual CPU interface与GIC交互</li>
<li>VMM通过physical CPU interface与GIC交互</li>
</ul>
</li>
<li>
<p>插入中断</p>
</li>
<li>
<p>通过<strong>GIC List Register</strong>插入中断号</p>
</li>
</ul>
<p><img src="/image/os/int.png" srcset="/img/loading.gif" alt="" /></p>
<ul>
<li>v4中，VMM需要通知GIC当前的调度信息，GIC才能将中断插入正确的CPU</li>
</ul>
<h2 id="轻量级虚拟化"><a class="markdownIt-Anchor" href="#轻量级虚拟化"></a> 轻量级虚拟化</h2>
<h3 id="fassfunction-as-a-service-and-serverless"><a class="markdownIt-Anchor" href="#fassfunction-as-a-service-and-serverless"></a> Fass(Function as a service) and Serverless</h3>
<ul>
<li>
<p>现有方案：虚拟机</p>
<ul>
<li>Function执行时创建虚拟机</li>
<li>Function执行完销毁虚拟机</li>
</ul>
</li>
<li>
<p>过于重量级，启动延时高</p>
</li>
<li>
<p>不用虚拟化方案</p>
<ul>
<li>window server允许多个用户同时访问远程桌面</li>
<li>缺点：缺少文件隔离</li>
</ul>
</li>
</ul>
<p><strong>chroot</strong></p>
<ul>
<li>为每个执行环境提供独立的文件系统视图</li>
<li>改变进程的根目录</li>
</ul>
<p>简单实现</p>
<ul>
<li>内核为每个用户保存其根目录</li>
<li>注意检查<code>../</code></li>
</ul>
<h3 id="基于namespace的限制"><a class="markdownIt-Anchor" href="#基于namespace的限制"></a> 基于namespace的限制</h3>
<ul>
<li>
<p>通过文件系统的namespace限制用户</p>
</li>
<li>
<p>可以在其他层(inode number)限制用户</p>
</li>
</ul>
<p>问题</p>
<ul>
<li>如何共享部分文件(<code>ls</code>)</li>
</ul>
<h2 id="linux容器"><a class="markdownIt-Anchor" href="#linux容器"></a> linux容器</h2>
<ul>
<li>由linux内核提供资源隔离</li>
<li>安全隔离：<code>linux namespace</code></li>
<li>性能隔离：<code>linux cgroup</code></li>
</ul>
<h3 id="linux-namespace"><a class="markdownIt-Anchor" href="#linux-namespace"></a> linux namespace</h3>
<ul>
<li>每种<strong>linux namespace</strong>封装一种全局资源</li>
</ul>
<ol>
<li>mount namespace</li>
</ol>
<ul>
<li>
<p>在内核分别记录每个NS对于挂载点的修改</p>
</li>
<li>
<p>访问挂载点时，根据当前NS的记录访问文件</p>
</li>
<li>
<p>每个NS有独立的NS文件系统树</p>
</li>
<li>
<p>修改挂载点只会修改自己的NS树</p>
</li>
<li>
<p>实现了文件的共享</p>
</li>
</ul>
<ol start="2">
<li>IPC namespace</li>
</ol>
<ul>
<li>每个IPC对象只能属于一个NS</li>
<li>进程只能在当前NS中寻找IPC对象</li>
</ul>
<ol start="3">
<li>network namespace</li>
</ol>
<p>linux 对多IP的支持</p>
<ul>
<li>内核中创建一个虚拟交换机</li>
<li>VM的网卡连接到交换机上</li>
</ul>
<p>Linux namespace</p>
<ul>
<li>
<p>每个NS拥有一套独立的网络资源(ip,网络设备)</p>
</li>
<li>
<p>新的NS默认仅有loopback设备</p>
</li>
<li>
<p>NS中的网卡连接到虚拟交换机上</p>
</li>
<li>
<p>通过ARP协议将多个ip与物理网卡MAC地址绑定，实现收多个ip的数据包</p>
</li>
</ul>
<ol start="4">
<li>PID namespace</li>
</ol>
<ul>
<li>每个namespace只能看到自己namespace得到PID</li>
<li>parent NS可以看到child NS的PID，反之不行</li>
<li>子NS中进程在父NS中也有PID</li>
<li>子NS中进程无法向外部发送信号</li>
</ul>
<ol start="5">
<li>user namespace</li>
</ol>
<ul>
<li>隔离用户权限</li>
<li>对NS内外UID和GID映射</li>
<li>每个NS都有UID为0的root用户，映射为外部的其他UID，在NS外部无root权限</li>
</ul>
<ol start="6">
<li>UTS namespace</li>
</ol>
<ul>
<li>每个NS拥有自己的hostname</li>
</ul>
<ol start="7">
<li>Cgroup(control group) namespace</li>
</ol>
<ul>
<li>实现资源隔离</li>
<li>将线程分组，对每组线程多种物理资源监控</li>
</ul>
<h1 id="网络协议栈"><a class="markdownIt-Anchor" href="#网络协议栈"></a> 网络协议栈</h1>
<h2 id="linux收包过程"><a class="markdownIt-Anchor" href="#linux收包过程"></a> linux收包过程</h2>
<p><img src="/image/os/linuxnet.png" srcset="/img/loading.gif" alt="" /></p>
<ol>
<li>DMA将数据传送到内核RX缓冲区</li>
<li>触发中断</li>
<li>cpu收到中断,触发中断处理程序(上半部)</li>
</ol>
<ul>
<li>分配<code>sk_buff</code>数据结构，将数据帧copy到接收队列</li>
<li>发出<strong>NET_RX_SOFTIRQ</strong>软中断，通知内核接收到数据帧</li>
</ul>
<ol start="4">
<li>内核在合适的时机(返回用户态之前)检查softirq队列并处理软中断(进入下半部)</li>
<li>将接收队列的数据帧copy到<code>sk_buff</code>缓冲区中</li>
<li>根据数据包的类型，调用对应的协议处理函数</li>
</ol>
<ul>
<li>TCP会将数据copy到socket的<strong>Recv-Q</strong>,唤醒等待在socket上的线程</li>
<li>用户调用<code>recv(buff)</code>将数据copy到用户态</li>
</ul>
<h1 id="操作系统调试"><a class="markdownIt-Anchor" href="#操作系统调试"></a> 操作系统调试</h1>
<ul>
<li>中断程序运行读取内部状态</li>
<li>获取程序异常退出原因</li>
<li>动态修改程序状态</li>
<li>控制追踪流</li>
</ul>
<h2 id="linux调试支持ptrace系统调用"><a class="markdownIt-Anchor" href="#linux调试支持ptrace系统调用"></a> linux调试支持：ptrace系统调用</h2>
<ol>
<li>子进程通过<code>PTRACE_TRACEME</code>将调试权交给父进程，父进程可以读取，修改子进程的状态</li>
<li>通过<code>PTRACE_ATTACH</code>调试指定进程</li>
</ol>
<p><strong>GDB捕捉异常信号</strong></p>
<p>GDB等待子进程事件，子进程发生时间后会通知父进程</p>
<ul>
<li><code>PTRACE_GETSIGINFO</code>获取被调试进程signal</li>
<li><code>PTRACE_GETREGS</code>获取被调试进程的RIP</li>
</ul>
<p><strong>断点</strong></p>
<ul>
<li>
<p>断点异常指令</p>
<ul>
<li>在执行到特定指令时，触发断点异常陷入内核</li>
<li>x86: <code>int 3</code>, AARCH64: <code>BKP</code></li>
</ul>
</li>
<li>
<p>单步调试</p>
<ul>
<li>在用户态执行一条指令后立即陷入内核</li>
<li>x86 Trap flag</li>
</ul>
</li>
</ul>
<ol>
<li><code>PTRACE_POKETEXT</code>修改进程代码为断点指令</li>
<li>子进程执行到断点，触发断点异常，产生<code>SIGTRAP</code>signal并通知GDB</li>
</ol>
<p><strong>内存断点</strong></p>
<ul>
<li>
<p>基本实现</p>
<ul>
<li>将内存地址所在页设为只读</li>
<li>访问时触发page fault</li>
<li>对该页所有的写操作均导致page fault</li>
</ul>
</li>
<li>
<p>断点寄存器</p>
<ul>
<li>当访存地址为寄存器中的值时，触发断点异常</li>
</ul>
</li>
</ul>
<p><strong>远程调试</strong></p>
<p><img src="/image/os/remotedebug.png" srcset="/img/loading.gif" alt="" /></p>
<ul>
<li>
<p>GDB客户端负责指令发送</p>
<ul>
<li>GDB远端串行协议(GDB remote serial protocol,RSP)</li>
</ul>
</li>
<li>
<p>GDB stub 控制调试应用</p>
</li>
</ul>
<h2 id="性能调试"><a class="markdownIt-Anchor" href="#性能调试"></a> 性能调试</h2>
<h3 id="确定内核执行中耗时较长的函数"><a class="markdownIt-Anchor" href="#确定内核执行中耗时较长的函数"></a> 确定内核执行中耗时较长的函数</h3>
<p><strong>硬件计数器</strong></p>
<ul>
<li>
<p>监控程序执行过程中处理器发生某些事件的次数</p>
<ul>
<li>e.g., 执行指令数量，缓存失效次数</li>
</ul>
</li>
<li>
<p>方法1：获取事件发生次数</p>
<ul>
<li>设置事件类型，打开计数器</li>
<li>一段时间后读取计数器</li>
<li>缺点：可能涉及对源代码修改(插桩)</li>
</ul>
</li>
<li>
<p>方法2：采样</p>
<ul>
<li>设置事件类型，打开计数器</li>
<li>当计数器溢出时，产生中断
<ul>
<li>在中断处理中获取地址信息</li>
<li>清空计数器，等待下一次中断</li>
</ul>
</li>
<li>每经过一定cycle触发一次中断，统计中断时指令地址，获取这些地址属于哪些函数</li>
</ul>
</li>
</ul>
<h4 id="linux-性能计数器采样支持"><a class="markdownIt-Anchor" href="#linux-性能计数器采样支持"></a> linux 性能计数器采样支持</h4>
<ul>
<li>
<p>性能相关事件 perf events</p>
<ul>
<li>以event的抽象暴露性能计数器</li>
<li>perf_event_open通知内核需要使用哪些计数器</li>
<li>采样过程有内核完成</li>
<li>采样结果放入内核与用户共享内存中</li>
</ul>
</li>
<li>
<p>前端工具perf</p>
<ul>
<li>perf工具包包装常见的性能分析方法</li>
<li><code>perf record -e cycles &lt;app&gt;</code></li>
<li><code>perf report</code></li>
</ul>
</li>
</ul>
<h4 id="基于中断采样的缺点"><a class="markdownIt-Anchor" href="#基于中断采样的缺点"></a> 基于中断采样的缺点</h4>
<ul>
<li>采样获取的指令地址不准确
<ul>
<li>中断发送需要时间，CPU收到中断时的指令地址可能有偏移</li>
<li>乱序执行</li>
</ul>
</li>
</ul>
<h3 id="控制流追踪"><a class="markdownIt-Anchor" href="#控制流追踪"></a> 控制流追踪</h3>
<ul>
<li>
<p>软件方法backtrace追踪</p>
<ul>
<li>问题：编译器优化去除栈帧</li>
</ul>
</li>
<li>
<p>硬件的控制流追踪</p>
<ul>
<li>
<p>记录jmp、call、中断导致跳转的前后位置</p>
</li>
<li>
<p>e.g.Last Branch Record(intel)</p>
<ul>
<li>两组寄存器分别构成栈，记录最近N次跳转信息</li>
</ul>
</li>
<li>
<p><code>perf record -e cycles -g &lt;app&gt;</code></p>
</li>
<li>
<p><code>perf report</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="静态追踪方法"><a class="markdownIt-Anchor" href="#静态追踪方法"></a> 静态追踪方法</h3>
<ul>
<li>
<p>在代码编写时插桩</p>
<ul>
<li>打印</li>
</ul>
</li>
<li>
<p>预置静态追踪函数</p>
<ul>
<li>e.g.,linux Tracepoint</li>
</ul>
</li>
<li>
<p>缺点</p>
<ul>
<li>修改跟踪点需要重新编译</li>
<li>有些函数没有tracepoint</li>
</ul>
</li>
</ul>
<h3 id="动态追踪方法"><a class="markdownIt-Anchor" href="#动态追踪方法"></a> 动态追踪方法</h3>
<ul>
<li>程序运行时，在不确定的代码位置插入一段动态指定的追踪函数</li>
<li>e.g.,linux kprobe，类似于断点调试</li>
</ul>
<ol>
<li>使用断点指令替换原指令</li>
<li>执行时产生异常</li>
<li>调用handler</li>
<li>恢复原指令，单步调试</li>
<li>重新设置断点指令，返回继续执行</li>
</ol>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">vfs_read</span><span class="hljs-params">(struct file* file,<span class="hljs-keyword">char</span> *buff,<span class="hljs-keyword">size_t</span> count,<span class="hljs-keyword">loff_t</span>*pos)</span></span>;</code></pre>
<ul>
<li>检查count的大小<br />
<code>perf probe --add 'vfs_read count=%dx:u64'</code></li>
</ul>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/os/">os</a>
                    
                      <a class="hover-with-bg" href="/tags/operating-system/">operating system</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2021/03/09/computer%20network/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">computer network</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2021/01/25/lex/">
                        <span class="hidden-mobile">lexcial</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "os&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.css" />
  
















</body>
</html>
